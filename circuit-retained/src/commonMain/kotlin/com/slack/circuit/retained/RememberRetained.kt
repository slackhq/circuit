// Copyright (C) 2022 Slack Technologies, LLC
// SPDX-License-Identifier: Apache-2.0
package com.slack.circuit.retained

import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.RememberObserver
import androidx.compose.runtime.SideEffect
import androidx.compose.runtime.SnapshotMutationPolicy
import androidx.compose.runtime.currentCompositeKeyHash
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.neverEqualPolicy
import androidx.compose.runtime.referentialEqualityPolicy
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.LocalSaveableStateRegistry
import androidx.compose.runtime.saveable.SaveableStateRegistry
import androidx.compose.runtime.saveable.Saver
import androidx.compose.runtime.saveable.SaverScope
import androidx.compose.runtime.snapshots.SnapshotMutableState
import androidx.compose.runtime.structuralEqualityPolicy

/**
 * Remember the value produced by [init].
 *
 * It behaves similarly to [remember], but the stored value will survive configuration changes, such
 * as a screen rotation.
 *
 * You can use it with a value stored inside [androidx.compose.runtime.mutableStateOf].
 *
 * This differs from `rememberSaveable` by not being tied to Android bundles or parcelable by
 * default, and instead keeps it in memory. You should take care to ensure that the state computed
 * by [init] does not capture anything that is not safe to persist across reconfiguration, such as
 * Navigators. The same caveats of `rememberSaveable` also still apply (i.e. do not retain Android
 * Contexts, Views, etc).
 *
 * By specifying a [saver], you can also serialize the retained value to the local saveable state registry, in
 * addition to keeping it in memory, to persist some state in saveable state through the process being killed.
 *
 * Care should be taken to choose the right retention mechanism for your use case.
 *
 * @param inputs A set of inputs such that, when any of them have changed, will cause the state to
 *   reset and [init] to be rerun
 * @param saver The [Saver] object which defines how the state is saved and restored. This is optional: the default
 *   [saver] does not save or restore anything to saveable state.
 * @param key An optional key to be used as a key for the saved value. If not provided we use the
 *   automatically generated by the Compose runtime which is unique for the every exact code
 *   location in the composition tree
 * @param init A factory function to create the initial value of this state
 */
@Composable
public fun <T : Any> rememberRetained(
  vararg inputs: Any?,
  saver: Saver<T, out Any> = Saver({ null }, { null }),
  key: String? = null,
  init: () -> T,
): T {
  val saveableStateRegistry = LocalSaveableStateRegistry.current
  val retainedStateRegistry = LocalRetainedStateRegistry.current

  val compositeKey = currentCompositeKeyHash
  // key is the one provided by the user or the one generated by the compose runtime
  val finalKey =
    if (!key.isNullOrEmpty()) {
      key
    } else {
      compositeKey.toString(MaxSupportedRadix)
    }

  @Suppress("UNCHECKED_CAST") (saver as Saver<T, Any>)

  val canRetainChecker = LocalCanRetainChecker.current ?: rememberCanRetainChecker()
  val holder =
    remember(canRetainChecker) {
      // value is restored using the retained registry first, the saveable registry second, or
      // created via [init]
      // lambda third
      @Suppress("UNCHECKED_CAST")
      val retainedRestored =
        retainedStateRegistry.consumeValue(finalKey) as? RetainableSaveableHolder.Value<T>
      val saveableRestored =
        saveableStateRegistry?.consumeRestored(finalKey)?.let { saver.restore(it) }
      val finalValue = retainedRestored?.value ?: saveableRestored ?: init()
      val finalInputs = retainedRestored?.inputs ?: inputs
      RetainableSaveableHolder(
        retainedStateRegistry = retainedStateRegistry,
        canRetainChecker = canRetainChecker,
        saveableStateRegistry = saveableStateRegistry,
        saver = saver,
        key = finalKey,
        value = finalValue,
        inputs = finalInputs,
        hasBeenRestoredFromRetained = retainedRestored != null,
      )
    }
  val value = holder.getValueIfInputsAreEqual(inputs) ?: init()
  SideEffect {
    holder.update(retainedStateRegistry, saveableStateRegistry, saver, finalKey, value, inputs)
  }
  return value
}

/**
 * Remember the value produced by [init].
 *
 * It behaves similarly to [remember], but the stored value will survive configuration changes, such
 * as a screen rotation.
 *
 * Use this overload if you remember a mutable state.
 *
 * @param inputs A set of inputs such that, when any of them have changed, will cause the state to
 *   reset and [init] to be rerun
 * @param stateSaver The [Saver] object which defines how the value inside the MutableState is saved
 *   and restored.
 * @param key An optional key to be used as a key for the saved value. If not provided we use the
 *   automatically generated by the Compose runtime which is unique for the every exact code
 *   location in the composition tree
 * @param init A factory function to create the initial value of this state
 */
@Composable
public fun <T> rememberRetained(
  vararg inputs: Any?,
  stateSaver: Saver<T, out Any>,
  key: String? = null,
  init: () -> MutableState<T>,
): MutableState<T> =
  rememberRetained(*inputs, saver = mutableStateSaver(stateSaver), key = key, init = init)

/** The maximum radix available for conversion to and from strings. */
private const val MaxSupportedRadix = 36

private class RetainableSaveableHolder<T>(
  private var retainedStateRegistry: RetainedStateRegistry?,
  private var canRetainChecker: CanRetainChecker,
  private var saveableStateRegistry: SaveableStateRegistry?,
  private var saver: Saver<T, Any>,
  private var key: String,
  private var value: T,
  private var inputs: Array<out Any?>,
  private var hasBeenRestoredFromRetained: Boolean = false,
) : RetainedValueProvider, RememberObserver, SaverScope {
  private var retainedStateEntry: RetainedStateRegistry.Entry? = null
  private var saveableStateEntry: SaveableStateRegistry.Entry? = null

  /** Value provider called by the registry. */
  private val valueProvider = {
    with(saver) { save(requireNotNull(value) { "Value should be initialized" }) }
  }

  fun update(
    retainedStateRegistry: RetainedStateRegistry?,
    saveableStateRegistry: SaveableStateRegistry?,
    saver: Saver<T, Any>,
    key: String,
    value: T,
    inputs: Array<out Any?>,
  ) {
    var retainedEntryIsOutdated = false
    var saveableEntryIsOutdated = false
    if (this.retainedStateRegistry !== retainedStateRegistry) {
      this.retainedStateRegistry = retainedStateRegistry
      retainedEntryIsOutdated = true
    }
    if (this.saveableStateRegistry !== saveableStateRegistry) {
      this.saveableStateRegistry = saveableStateRegistry
      saveableEntryIsOutdated = true
    }
    if (this.key != key) {
      this.key = key
      retainedEntryIsOutdated = true
      saveableEntryIsOutdated = true
    }
    if (this.value !== value) {
      // If the value changes, clear the hasBeenRestored flag
      hasBeenRestoredFromRetained = false
    }
    this.saver = saver
    this.value = value
    this.inputs = inputs
    if (retainedStateEntry != null && retainedEntryIsOutdated) {
      retainedStateEntry?.unregister()
      retainedStateEntry = null
      registerRetained()
    }
    if (saveableStateRegistry != null && saveableEntryIsOutdated) {
      saveableStateEntry?.unregister()
      saveableStateEntry = null
      registerSaveable()
    }
  }

  private fun registerRetained() {
    val registry = retainedStateRegistry
    require(retainedStateEntry == null) { "entry($retainedStateEntry) is not null" }
    if (registry != null) {
      retainedStateEntry = registry.registerValue(key, this)
    }
  }

  private fun registerSaveable() {
    val registry = saveableStateRegistry
    require(saveableStateEntry == null) { "entry($saveableStateEntry) is not null" }
    if (registry != null) {
      registry.requireCanBeSaved(valueProvider())
      saveableStateEntry = registry.registerProvider(key, valueProvider)
    }
  }

  /** Value provider called by the registry. */
  override fun invoke(): Any =
    Value(value = requireNotNull(value) { "Value should be initialized" }, inputs = inputs)

  override fun canBeSaved(value: Any): Boolean {
    val registry = saveableStateRegistry
    return registry == null || registry.canBeSaved(value)
  }

  fun saveIfRetainable() {
    val v = value ?: return
    val reg = retainedStateRegistry ?: return

    if (!canRetainChecker.canRetain(reg)) {
      retainedStateEntry?.unregister()
      when (v) {
        // If value is a RememberObserver, we notify that it has been forgotten.
        is RememberObserver -> v.onForgotten()
        // Or if its a registry, we need to tell it to clear, which will forward the 'forgotten'
        // call onto its values
        is RetainedStateRegistry -> {
          // First we saveAll, which flattens down the value providers to our retained list
          v.saveAll()
          // Now we drop all retained values
          v.forgetUnclaimedValues()
        }
      }
    } else if (v is RetainedStateRegistry) {
      // If the value is a RetainedStateRegistry, we need to take care to retain it.
      // First we tell it to saveAll, to retain it's values. Then we need to tell the host
      // registry to retain the child registry.
      v.saveAll()
      reg.saveValue(key)
    }
  }

  override fun onRemembered() {
    registerRetained()
    registerSaveable()

    // If value is a RememberObserver, we notify that it has remembered
    if (!hasBeenRestoredFromRetained) {
      val v = value
      if (v is RememberObserver) v.onRemembered()
    }
  }

  override fun onForgotten() {
    saveIfRetainable()
    saveableStateEntry?.unregister()
  }

  override fun onAbandoned() {
    saveIfRetainable()
    saveableStateEntry?.unregister()
  }

  fun getValueIfInputsAreEqual(inputs: Array<out Any?>): T? {
    return value.takeIf { inputs.contentEquals(this.inputs) }
  }

  class Value<T>(override val value: T, val inputs: Array<out Any?>) : RetainedValueHolder<T>
}

private fun SaveableStateRegistry.requireCanBeSaved(value: Any?) {
  require(value == null || canBeSaved(value)) {
    if (value is SnapshotMutableState<*>) {
      if (
        value.policy !== neverEqualPolicy<Any?>() &&
          value.policy !== structuralEqualityPolicy<Any?>() &&
          value.policy !== referentialEqualityPolicy<Any?>()
      ) {
        "If you use a custom SnapshotMutationPolicy for your MutableState you have to" +
          " write a custom Saver"
      } else {
        "MutableState containing ${value.value} cannot be saved using the current " +
          "SaveableStateRegistry. The default implementation only supports types " +
          "which can be stored inside the Bundle. Please consider implementing a " +
          "custom Saver for this class and pass it as a stateSaver parameter to " +
          "rememberRetainedSaveable()."
      }
    } else {
      "$value cannot be saved using the current SaveableStateRegistry. The default " +
        "implementation only supports types which can be stored inside the Bundle" +
        ". Please consider implementing a custom Saver for this class and pass it" +
        " to rememberRetainedSaveable()."
    }
  }
}

@Suppress("UNCHECKED_CAST")
private fun <T> mutableStateSaver(inner: Saver<T, out Any>) =
  with(inner as Saver<T, Any>) {
    Saver<MutableState<T>, MutableState<Any?>>(
      save = { state ->
        require(state is SnapshotMutableState<T>) {
          "If you use a custom MutableState implementation you have to write a custom " +
            "Saver and pass it as a saver param to rememberRetainedSaveable()"
        }
        val saved = save(state.value)
        if (saved != null) {
          mutableStateOf(saved, state.policy as SnapshotMutationPolicy<Any?>)
        } else {
          // if the inner saver returned null we need to return null as well so the
          // user's init lambda will be used instead of restoring mutableStateOf(null)
          null
        }
      },
      restore =
        @Suppress("UNCHECKED_CAST", "ExceptionMessage") {
          require(it is SnapshotMutableState<Any?>)
          mutableStateOf(
            if (it.value != null) restore(it.value!!) else null,
            it.policy as SnapshotMutationPolicy<T?>,
          )
            as MutableState<T>
        },
    )
  }
