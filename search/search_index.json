{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u26a1\ufe0f Circuit \u00b6 \ud83d\udea7 Under construction \ud83d\udea7 This project is very much a work in progress and far from finished! Overview \u00b6 Circuit is a simple, lightweight, and extensible framework for building Kotlin applications that\u2019s Compose from the ground up. Compose Runtime vs. Compose UI Compose itself is essentially two libraries \u2013 Compose Compiler and Compose UI. Most folks usually think of Compose UI, but the compiler (and associated runtime) are actually not specific to UI at all and offer powerful state management APIs. Jake Wharton has an excellent post about this: https://jakewharton.com/a-jetpack-compose-by-any-other-name/ It builds upon core principles we already know like Presenters and UDF, and adds native support in its framework for all the other requirements we set out for above. It\u2019s heavily influenced by Cash App\u2019s Broadway architecture ( talked about at Droidcon NYC , also very derived from our conversations with them). Circuit\u2019s core components are its Presenter and Ui interfaces. A Presenter and a Ui cannot directly access each other. They can only communicate through state and event emissions. UIs are compose-first. Presenters are also compose-first. They do not emit Compose UI, but they do use the Compose runtime to manage and emit state. Both Presenter and Ui each have a single composable function. In most cases, Circuit automatically connects presenters and UIs. Presenter and Ui are both generic types, with generics to define the UiState types they communicate with. They are keyed by Screen s. One runs a new Presenter / Ui pairing by requesting them with a given Screen that they understand. Circuits The pairing of a Presenter and Ui for a given Screen key is what we semantically call a \u201ccircuit\u201d. Your application is composed of \u201ccircuits\u201d. A simple counter Presenter + Ui pairing would be a \u201ccounter circuit\u201d. Nested presenter/UIs would be \u201cnested circuits\u201d or \u201csub circuits\u201d Composite presenter/UIs would be \u201ccomposite circuits\u201d etc etc. Circuit\u2019s repo ( https://github.com/slackhq/circuit ) is being actively developed in the open, which allows us to continue collaborating with external folks too. We have a trivial-but-not-too-trivial sample app that we have been developing in it to serve as a demo for a number of common patterns in Circuit use. Counter Example \u00b6 This is a very simple case of a Counter circuit that displays the count and has buttons to increment and decrement. There\u2019s some glue code missing from this example that\u2019s covered in the Code Gen (TODO link) section later. @Parcelize object CounterScreen : Screen { data class CounterState ( val count : Int , val eventSink : ( CounterEvent ) -> Unit , ) : CircuitUiState sealed interface CounterEvent : CircuitUiEvent { object Increment : CounterEvent object Decrement : CounterEvent } } @CircuitInject < CounterScreen > @Composable fun CounterPresenter (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } @CircuitInject < CounterScreen > @Composable fun Counter ( state : CounterState ) { Box ( Modifier . fillMaxSize ()) { Column ( Modifier . align ( Alignment . Center )) { Text ( modifier = Modifier . align ( CenterHorizontally ), text = \"Count: ${ state . count } \" , style = MaterialTheme . typography . displayLarge ) Spacer ( modifier = Modifier . height ( 16. dp )) val eventSink = state . eventSink Button ( modifier = Modifier . align ( CenterHorizontally ), onClick = { eventSink ( CounterEvent . Increment ) } ) { Icon ( rememberVectorPainter ( Icons . Filled . Add ), \"Increment\" ) } Button ( modifier = Modifier . align ( CenterHorizontally ), onClick = { eventSink ( CounterEvent . Decrement ) } ) { Icon ( rememberVectorPainter ( Icons . Filled . Remove ), \"Decrement\" ) } } } } License \u00b6 Copyright 2022 Slack Technologies, LLC Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Introduction"},{"location":"#circuit","text":"\ud83d\udea7 Under construction \ud83d\udea7 This project is very much a work in progress and far from finished!","title":"\u26a1\ufe0f Circuit"},{"location":"#overview","text":"Circuit is a simple, lightweight, and extensible framework for building Kotlin applications that\u2019s Compose from the ground up. Compose Runtime vs. Compose UI Compose itself is essentially two libraries \u2013 Compose Compiler and Compose UI. Most folks usually think of Compose UI, but the compiler (and associated runtime) are actually not specific to UI at all and offer powerful state management APIs. Jake Wharton has an excellent post about this: https://jakewharton.com/a-jetpack-compose-by-any-other-name/ It builds upon core principles we already know like Presenters and UDF, and adds native support in its framework for all the other requirements we set out for above. It\u2019s heavily influenced by Cash App\u2019s Broadway architecture ( talked about at Droidcon NYC , also very derived from our conversations with them). Circuit\u2019s core components are its Presenter and Ui interfaces. A Presenter and a Ui cannot directly access each other. They can only communicate through state and event emissions. UIs are compose-first. Presenters are also compose-first. They do not emit Compose UI, but they do use the Compose runtime to manage and emit state. Both Presenter and Ui each have a single composable function. In most cases, Circuit automatically connects presenters and UIs. Presenter and Ui are both generic types, with generics to define the UiState types they communicate with. They are keyed by Screen s. One runs a new Presenter / Ui pairing by requesting them with a given Screen that they understand. Circuits The pairing of a Presenter and Ui for a given Screen key is what we semantically call a \u201ccircuit\u201d. Your application is composed of \u201ccircuits\u201d. A simple counter Presenter + Ui pairing would be a \u201ccounter circuit\u201d. Nested presenter/UIs would be \u201cnested circuits\u201d or \u201csub circuits\u201d Composite presenter/UIs would be \u201ccomposite circuits\u201d etc etc. Circuit\u2019s repo ( https://github.com/slackhq/circuit ) is being actively developed in the open, which allows us to continue collaborating with external folks too. We have a trivial-but-not-too-trivial sample app that we have been developing in it to serve as a demo for a number of common patterns in Circuit use.","title":"Overview"},{"location":"#counter-example","text":"This is a very simple case of a Counter circuit that displays the count and has buttons to increment and decrement. There\u2019s some glue code missing from this example that\u2019s covered in the Code Gen (TODO link) section later. @Parcelize object CounterScreen : Screen { data class CounterState ( val count : Int , val eventSink : ( CounterEvent ) -> Unit , ) : CircuitUiState sealed interface CounterEvent : CircuitUiEvent { object Increment : CounterEvent object Decrement : CounterEvent } } @CircuitInject < CounterScreen > @Composable fun CounterPresenter (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } @CircuitInject < CounterScreen > @Composable fun Counter ( state : CounterState ) { Box ( Modifier . fillMaxSize ()) { Column ( Modifier . align ( Alignment . Center )) { Text ( modifier = Modifier . align ( CenterHorizontally ), text = \"Count: ${ state . count } \" , style = MaterialTheme . typography . displayLarge ) Spacer ( modifier = Modifier . height ( 16. dp )) val eventSink = state . eventSink Button ( modifier = Modifier . align ( CenterHorizontally ), onClick = { eventSink ( CounterEvent . Increment ) } ) { Icon ( rememberVectorPainter ( Icons . Filled . Add ), \"Increment\" ) } Button ( modifier = Modifier . align ( CenterHorizontally ), onClick = { eventSink ( CounterEvent . Decrement ) } ) { Icon ( rememberVectorPainter ( Icons . Filled . Remove ), \"Decrement\" ) } } } }","title":"Counter Example"},{"location":"#license","text":"Copyright 2022 Slack Technologies, LLC Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"circuit-content/","text":"CircuitContent \u00b6 The simplest entry point of a circuit is the composable CircuitContent function. This function accepts a Screen and automatically finds and pairs corresponding Presenter and Ui instances to render in it. setContent { CircuitContent ( HomeScreen ) }","title":"CircuitContent"},{"location":"circuit-content/#circuitcontent","text":"The simplest entry point of a circuit is the composable CircuitContent function. This function accepts a Screen and automatically finds and pairs corresponding Presenter and Ui instances to render in it. setContent { CircuitContent ( HomeScreen ) }","title":"CircuitContent"},{"location":"code-gen/","text":"Code Generation \u00b6 We plan to include code gen tools to cover most of any boilerplate, making the common paths simple while allowing for more complex hand-written structures when needed. At a high level using the examples above, we want to generate the following bits of code for users class FavoritesScreenUiFactory class FavoritesScreenPresenterFactory private fun favoritesUi () We\u2019re intentionally saving implementing this step last as it makes making API changes more difficult. Follow along progress here: https://github.com/slackhq/circuit/issues/13","title":"Code Generation"},{"location":"code-gen/#code-generation","text":"We plan to include code gen tools to cover most of any boilerplate, making the common paths simple while allowing for more complex hand-written structures when needed. At a high level using the examples above, we want to generate the following bits of code for users class FavoritesScreenUiFactory class FavoritesScreenPresenterFactory private fun favoritesUi () We\u2019re intentionally saving implementing this step last as it makes making API changes more difficult. Follow along progress here: https://github.com/slackhq/circuit/issues/13","title":"Code Generation"},{"location":"code-of-conduct/","text":"Code of Conduct \u00b6 Introduction \u00b6 Diversity and inclusion make our community strong. We encourage participation from the most varied and diverse backgrounds possible and want to be very clear about where we stand. Our goal is to maintain a safe, helpful and friendly community for everyone, regardless of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other defining characteristic. This code and related procedures also apply to unacceptable behavior occurring outside the scope of community activities, in all community venues (online and in-person) as well as in all one-on-one communications, and anywhere such behavior has the potential to adversely affect the safety and well-being of community members. For more information on our code of conduct, please visit https://slackhq.github.io/code-of-conduct","title":"CoC"},{"location":"code-of-conduct/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"code-of-conduct/#introduction","text":"Diversity and inclusion make our community strong. We encourage participation from the most varied and diverse backgrounds possible and want to be very clear about where we stand. Our goal is to maintain a safe, helpful and friendly community for everyone, regardless of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other defining characteristic. This code and related procedures also apply to unacceptable behavior occurring outside the scope of community activities, in all community venues (online and in-person) as well as in all one-on-one communications, and anywhere such behavior has the potential to adversely affect the safety and well-being of community members. For more information on our code of conduct, please visit https://slackhq.github.io/code-of-conduct","title":"Introduction"},{"location":"contributing/","text":"Contributors Guide \u00b6 Note that this project is considered READ-ONLY. You are welcome to discuss or ask questions in the discussions section of the repo, but we do not normally accept external contributions without prior discussion. Development \u00b6 Check out this repo with Android Studio. It\u2019s a standard gradle project and conventional to checkout. The primary project is circuit . The primary sample is samples/star . This project is written in Kotlin and should only use Kotlin. Code formatting is checked via Spotless . To run the formatter, use the spotlessApply command. ./gradlew spotlessApply","title":"Contributing"},{"location":"contributing/#contributors-guide","text":"Note that this project is considered READ-ONLY. You are welcome to discuss or ask questions in the discussions section of the repo, but we do not normally accept external contributions without prior discussion.","title":"Contributors Guide"},{"location":"contributing/#development","text":"Check out this repo with Android Studio. It\u2019s a standard gradle project and conventional to checkout. The primary project is circuit . The primary sample is samples/star . This project is written in Kotlin and should only use Kotlin. Code formatting is checked via Spotless . To run the formatter, use the spotlessApply command. ./gradlew spotlessApply","title":"Development"},{"location":"factories/","text":"Factories \u00b6 At its core, Circuit works on the Factory pattern. Every Presenter and Ui is contributed to a CircuitConfig instance by a corresponding factory that creates them for given Screen s. These are intended to be aggregated in the DI layer and added to a CircuitConfig instance during construction. val circuitConfig = CircuitConfig . Builder () . addUiFactory ( FavoritesUiFactory ()) . addPresenterFactory ( FavoritesPresenterFactory ()) . build () Look familiar? If you\u2019ve used Moshi or Retrofit, these should feel fairly familiar! Presenter factories can be generated or hand-written, depending on if they aggregate an entire screen or are simple one-offs. Presenters are also given access to the current Navigator in this level. class FavoritesScreenPresenterFactory @Inject constructor ( private val favoritesPresenterFactory : FavoritesPresenter . Factory , ) : Presenter . Factory { override fun create ( screen : Screen , navigator : Navigator ): Presenter <*>? { return when ( screen ) { is FavoritesScreen -> favoritesPresenterFactory . create ( screen , navigator ) else -> null } } } UI factories are similar, but generally should not aggregate other UIs unless there\u2019s a DI-specific reason to do so (which there usually isn\u2019t!). class FavoritesScreenUiFactory : @Inject constructor () : Ui . Factory { override fun create ( screen : Screen ): ScreenUi? { return when ( screen ) { is FavoritesScreen -> ScreenUi ( favoritesUi ()) else null -> } } } private fun favoritesUi () = ui < State > { state -> Favorites ( state ) } Info Note how these return a ScreenUi class that holds the Ui instance. We are using this indirection as a toe-hold for possible other future UI metadata, such as Modifier instances. We canonically write these out as a separate function ( favoritesUi() ) that returns a Ui , which in turn calls through to the real (basic) Compose UI function ( Favorites() ). This ensures our basic compose functions are top-level and accessible by tests, and also discourages storing anything in class members rather than idiomatic composable state vars.","title":"Factories"},{"location":"factories/#factories","text":"At its core, Circuit works on the Factory pattern. Every Presenter and Ui is contributed to a CircuitConfig instance by a corresponding factory that creates them for given Screen s. These are intended to be aggregated in the DI layer and added to a CircuitConfig instance during construction. val circuitConfig = CircuitConfig . Builder () . addUiFactory ( FavoritesUiFactory ()) . addPresenterFactory ( FavoritesPresenterFactory ()) . build () Look familiar? If you\u2019ve used Moshi or Retrofit, these should feel fairly familiar! Presenter factories can be generated or hand-written, depending on if they aggregate an entire screen or are simple one-offs. Presenters are also given access to the current Navigator in this level. class FavoritesScreenPresenterFactory @Inject constructor ( private val favoritesPresenterFactory : FavoritesPresenter . Factory , ) : Presenter . Factory { override fun create ( screen : Screen , navigator : Navigator ): Presenter <*>? { return when ( screen ) { is FavoritesScreen -> favoritesPresenterFactory . create ( screen , navigator ) else -> null } } } UI factories are similar, but generally should not aggregate other UIs unless there\u2019s a DI-specific reason to do so (which there usually isn\u2019t!). class FavoritesScreenUiFactory : @Inject constructor () : Ui . Factory { override fun create ( screen : Screen ): ScreenUi? { return when ( screen ) { is FavoritesScreen -> ScreenUi ( favoritesUi ()) else null -> } } } private fun favoritesUi () = ui < State > { state -> Favorites ( state ) } Info Note how these return a ScreenUi class that holds the Ui instance. We are using this indirection as a toe-hold for possible other future UI metadata, such as Modifier instances. We canonically write these out as a separate function ( favoritesUi() ) that returns a Ui , which in turn calls through to the real (basic) Compose UI function ( Favorites() ). This ensures our basic compose functions are top-level and accessible by tests, and also discourages storing anything in class members rather than idiomatic composable state vars.","title":"Factories"},{"location":"interop/","text":"Interop \u00b6 TODO: https://github.com/slackhq/circuit/issues/42","title":"Interop"},{"location":"interop/#interop","text":"TODO: https://github.com/slackhq/circuit/issues/42","title":"Interop"},{"location":"navigation/","text":"Navigation \u00b6 For navigable contents, we have a custom compose-based backstack implementation that the androidx folks shared with us. Navigation becomes two parts: A BackStack , where we use a SaveableBackStack implementation that saves a stack of Screen s and the ProvidedValues for each record on that stack (allowing us to save and restore on configuration changes automatically). A Navigator , which is a simple interface that we can point at a BackStack and offers simple goTo(<screen>) / pop() semantics. These are offered to presenters to perform navigation as needed to other screens. A new navigable content surface is handled via the NavigableCircuitContent functions. setContent { val backstack = rememberSaveableBackStack { push ( HomeScreen ) } val navigator = rememberCircuitNavigator ( backstack , onBackPressedDispatcher :: onBackPressed ) NavigableCircuitContent ( navigator , backstack ) } Presenters are then given access to these navigator instances via Presenter.Factory (described in TODO link Factories), which they can save if needed to perform navigation. fun showAddFavorites () { navigator . goTo ( AddFavorites ( externalId = uuidGenerator . generate () ) ) } Nested Navigation \u00b6 Navigation carries special semantic value in CircuitContent as well, where it\u2019s common for UIs to want to curry navigation events emitted by nested UIs. For this case, there\u2019s a CircuitContent overload that accepts an optional onNavEvent callback that you must then forward to a Navigator instance. @Composable fun ParentUi ( state : ParentState ) { CircuitContent ( NestedScreen , onNavEvent = { navEvent -> state . eventSink ( NestedNav ( navEvent )) }) } @Composable fun ParentPresenter ( navigator : Navigator ): ParentState { return ParentState (...) { event -> when ( event ) { is NestedNav -> navigator . onNavEvent ( event . navEvent ) } } } @Composable fun NestedPresenter ( navigator : Navigator ): NestedState { // These are forwarded up! navigator . goTo ( AnotherScreen ) // ... }","title":"Navigation"},{"location":"navigation/#navigation","text":"For navigable contents, we have a custom compose-based backstack implementation that the androidx folks shared with us. Navigation becomes two parts: A BackStack , where we use a SaveableBackStack implementation that saves a stack of Screen s and the ProvidedValues for each record on that stack (allowing us to save and restore on configuration changes automatically). A Navigator , which is a simple interface that we can point at a BackStack and offers simple goTo(<screen>) / pop() semantics. These are offered to presenters to perform navigation as needed to other screens. A new navigable content surface is handled via the NavigableCircuitContent functions. setContent { val backstack = rememberSaveableBackStack { push ( HomeScreen ) } val navigator = rememberCircuitNavigator ( backstack , onBackPressedDispatcher :: onBackPressed ) NavigableCircuitContent ( navigator , backstack ) } Presenters are then given access to these navigator instances via Presenter.Factory (described in TODO link Factories), which they can save if needed to perform navigation. fun showAddFavorites () { navigator . goTo ( AddFavorites ( externalId = uuidGenerator . generate () ) ) }","title":"Navigation"},{"location":"navigation/#nested-navigation","text":"Navigation carries special semantic value in CircuitContent as well, where it\u2019s common for UIs to want to curry navigation events emitted by nested UIs. For this case, there\u2019s a CircuitContent overload that accepts an optional onNavEvent callback that you must then forward to a Navigator instance. @Composable fun ParentUi ( state : ParentState ) { CircuitContent ( NestedScreen , onNavEvent = { navEvent -> state . eventSink ( NestedNav ( navEvent )) }) } @Composable fun ParentPresenter ( navigator : Navigator ): ParentState { return ParentState (...) { event -> when ( event ) { is NestedNav -> navigator . onNavEvent ( event . navEvent ) } } } @Composable fun NestedPresenter ( navigator : Navigator ): NestedState { // These are forwarded up! navigator . goTo ( AnotherScreen ) // ... }","title":"Nested Navigation"},{"location":"presenter/","text":"Presenter \u00b6 The core Presenter interface is this: interface Presenter < UiState : CircuitUiState > { @Composable fun present (): UiState } Presenters are solely intended to be business logic for your UI and a translation layer in front of your data layers. They are generally Dagger-injected types as the data layers they interpret are usually coming from the DI graph. In simple cases, they can be typed as a simple @Composable presenter function and Circuit code gen (TODO link) can generate the corresponding interface and (TODO link) factory for you. A very simple presenter can look like this: class FavoritesPresenter (...) : Presenter < State > { @Composable override fun present (): State { var favorites by remember { mutableStateOf ( < initial > ) } return State ( favorites ) { event -> ... } } } In this example, the present() function simply computes a state and returns it. If it has UI events to handle, an eventSink: (Event) -> Unit property should be exposed in the State type it returns. With DI, the above example becomes something more like this: class FavoritesPresenter @AssistedInject constructor ( @Assisted private val screen : FavoritesScreen , @Assisted private val navigator : Navigator , private val favoritesRepository : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { // ... } @AssistedFactory fun interface Factory { fun create ( screen : FavoritesScreen , navigator : Navigator ): FavoritesPresenter } } Assisted injection allows passing on the screen and navigator from the relevant Presenter.Factory to this presenter for further reference. When dealing with nested presenters, a presenter could bypass implementing a class entirely by simply being written as a function that other presenters can use. // From cashapp/molecule's README examples @Composable fun ProfilePresenter ( userFlow : Flow < User > , balanceFlow : Flow < Long > , ): ProfileModel { val user by userFlow . collectAsState ( null ) val balance by balanceFlow . collectAsState ( 0L ) return if ( user == null ) { Loading } else { Data ( user . name , balance ) } } Presenters can present other presenters by injecting their assisted factories/providers, but note that this makes them a composite presenter that is now assuming responsibility for managing state of multiple nested presenters. We have an example of this in the Circuit repo . Retention \u00b6 There are three types of composable retention functions used in Circuit. remember \u2013 from Compose, remembers a value across recompositions. Can be any type. rememberRetained \u2013 custom, remembers a value across recompositions and configuration changes. Can be any type, but should not retain leak-able things like Navigator instances or Context instances. Backed by a hidden ViewModel on Android. rememberSaveable \u2013 from Compose, remembers a value across recompositions, configuration changes, and process death. Must be Parcelable or implement a custom Saver , should not retain leakable things like Navigator instances or Context instances. Backed by the framework saved instance state system. Developers should use the right tool accordingly depending on their use case. Consider these three examples. The first one will preserve the count value across recompositions, but not configuration changes or process death. @Composable fun CounterPresenter (): CounterState { var count by remember { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } The second one will preserve the state across recompositions and configuration changes, but not process death. @Composable fun CounterPresenter (): CounterState { var count by rememberRetained { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } The third case will preserve the count state across recompositions, configuration changes, and process death. However, it only works with primitives or Parcelable state types. @Composable fun CounterPresenter (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } }","title":"Presenter"},{"location":"presenter/#presenter","text":"The core Presenter interface is this: interface Presenter < UiState : CircuitUiState > { @Composable fun present (): UiState } Presenters are solely intended to be business logic for your UI and a translation layer in front of your data layers. They are generally Dagger-injected types as the data layers they interpret are usually coming from the DI graph. In simple cases, they can be typed as a simple @Composable presenter function and Circuit code gen (TODO link) can generate the corresponding interface and (TODO link) factory for you. A very simple presenter can look like this: class FavoritesPresenter (...) : Presenter < State > { @Composable override fun present (): State { var favorites by remember { mutableStateOf ( < initial > ) } return State ( favorites ) { event -> ... } } } In this example, the present() function simply computes a state and returns it. If it has UI events to handle, an eventSink: (Event) -> Unit property should be exposed in the State type it returns. With DI, the above example becomes something more like this: class FavoritesPresenter @AssistedInject constructor ( @Assisted private val screen : FavoritesScreen , @Assisted private val navigator : Navigator , private val favoritesRepository : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { // ... } @AssistedFactory fun interface Factory { fun create ( screen : FavoritesScreen , navigator : Navigator ): FavoritesPresenter } } Assisted injection allows passing on the screen and navigator from the relevant Presenter.Factory to this presenter for further reference. When dealing with nested presenters, a presenter could bypass implementing a class entirely by simply being written as a function that other presenters can use. // From cashapp/molecule's README examples @Composable fun ProfilePresenter ( userFlow : Flow < User > , balanceFlow : Flow < Long > , ): ProfileModel { val user by userFlow . collectAsState ( null ) val balance by balanceFlow . collectAsState ( 0L ) return if ( user == null ) { Loading } else { Data ( user . name , balance ) } } Presenters can present other presenters by injecting their assisted factories/providers, but note that this makes them a composite presenter that is now assuming responsibility for managing state of multiple nested presenters. We have an example of this in the Circuit repo .","title":"Presenter"},{"location":"presenter/#retention","text":"There are three types of composable retention functions used in Circuit. remember \u2013 from Compose, remembers a value across recompositions. Can be any type. rememberRetained \u2013 custom, remembers a value across recompositions and configuration changes. Can be any type, but should not retain leak-able things like Navigator instances or Context instances. Backed by a hidden ViewModel on Android. rememberSaveable \u2013 from Compose, remembers a value across recompositions, configuration changes, and process death. Must be Parcelable or implement a custom Saver , should not retain leakable things like Navigator instances or Context instances. Backed by the framework saved instance state system. Developers should use the right tool accordingly depending on their use case. Consider these three examples. The first one will preserve the count value across recompositions, but not configuration changes or process death. @Composable fun CounterPresenter (): CounterState { var count by remember { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } The second one will preserve the state across recompositions and configuration changes, but not process death. @Composable fun CounterPresenter (): CounterState { var count by rememberRetained { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } The third case will preserve the count state across recompositions, configuration changes, and process death. However, it only works with primitives or Parcelable state types. @Composable fun CounterPresenter (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } }","title":"Retention"},{"location":"screen/","text":"Screen \u00b6 The core Screen interface is this: interface Screen : Parcelable These types are Parcelable for saveability in our backstack and easy deeplinking. A Screen can be a simple marker object type or a data object with information to pass on. @Parcelize data class AddFavorites ( val externalId : UUID ) : Screen These are used by Navigator s (when called from presenters) or CircuitContent (when called from UIs) to start a new sub-circuit. // In a presenter class fun showAddFavorites () { navigator . goTo ( AddFavorites ( externalId = uuidGenerator . generate () ) ) }","title":"Screen"},{"location":"screen/#screen","text":"The core Screen interface is this: interface Screen : Parcelable These types are Parcelable for saveability in our backstack and easy deeplinking. A Screen can be a simple marker object type or a data object with information to pass on. @Parcelize data class AddFavorites ( val externalId : UUID ) : Screen These are used by Navigator s (when called from presenters) or CircuitContent (when called from UIs) to start a new sub-circuit. // In a presenter class fun showAddFavorites () { navigator . goTo ( AddFavorites ( externalId = uuidGenerator . generate () ) ) }","title":"Screen"},{"location":"states-and-events/","text":"States and Events \u00b6 The core state and event interfaces in Circuit are CircuitUiState and CircuitUiEvent . All state and event types should implement/extend these marker interfaces. Presenters are simple functions that determine and return composable states. UIs are simple functions that render states. Uis can emit events via eventSink properties in state classes, which presenters then handle. These are the core building blocks! States and events should be immutable value types. Wait, event callbacks in state types? Yep! This may feel like a departure from how you\u2019ve written UDF patterns in the past, but we really like it. We tried different patterns before with event Flow s and having Circuit internals manage these for you, but we found they came with tradeoffs and friction points that we could avoid by just treating event emissions as another aspect of state. The end result is a tidier structure of state + event flows. Simpler cognitive overheads due to not always using Flow for events, which comes with caveats in compose (wrapping operators in remember calls, pipelining nested event flows, etc) Simple event-less UIs \u2013 state just doesn\u2019t have an event sink. Simpler testing \u2013 no manual event flow needed. You end up writing more realistic tests where you tick along your presenter by emitting with its returned states directly. Different state types can have different event handling (e.g. Click may not make sense for Loading states). No internal ceremony around setting up a Channel and multicasting event streams. No risk of dropping events (unlike Flow ). Note Currently, while functions are treated as implicitly Stable by the compose compiler, they not skippable when they\u2019re non-composable Unit-returning lambdas with equal-but-unstable captures. This may change though, and would be another free benefit for this case. A longer-form writeup can be found in this PR .","title":"States and Events"},{"location":"states-and-events/#states-and-events","text":"The core state and event interfaces in Circuit are CircuitUiState and CircuitUiEvent . All state and event types should implement/extend these marker interfaces. Presenters are simple functions that determine and return composable states. UIs are simple functions that render states. Uis can emit events via eventSink properties in state classes, which presenters then handle. These are the core building blocks! States and events should be immutable value types. Wait, event callbacks in state types? Yep! This may feel like a departure from how you\u2019ve written UDF patterns in the past, but we really like it. We tried different patterns before with event Flow s and having Circuit internals manage these for you, but we found they came with tradeoffs and friction points that we could avoid by just treating event emissions as another aspect of state. The end result is a tidier structure of state + event flows. Simpler cognitive overheads due to not always using Flow for events, which comes with caveats in compose (wrapping operators in remember calls, pipelining nested event flows, etc) Simple event-less UIs \u2013 state just doesn\u2019t have an event sink. Simpler testing \u2013 no manual event flow needed. You end up writing more realistic tests where you tick along your presenter by emitting with its returned states directly. Different state types can have different event handling (e.g. Click may not make sense for Loading states). No internal ceremony around setting up a Channel and multicasting event streams. No risk of dropping events (unlike Flow ). Note Currently, while functions are treated as implicitly Stable by the compose compiler, they not skippable when they\u2019re non-composable Unit-returning lambdas with equal-but-unstable captures. This may change though, and would be another free benefit for this case. A longer-form writeup can be found in this PR .","title":"States and Events"},{"location":"testing/","text":"Testing \u00b6 Circuit is designed to make testing as easy as possible. Its core components are not mockable nor do they need to be mocked. Fakes are provided where needed, everything else can be used directly. Circuit will have a test artifact containing APIs to aid testing both presenters and composable UIs: Presenter.test() - an extension function that bridges the Compose and coroutines world. Use of this function is recommended for testing presenter state emissions and incoming UI events. Under the hood it leverages Molecule and Turbine . FakeNavigator - a test fake implementing the Circuit/Navigator interface. Use of this object is recommended when testing screen navigation (ie. goTo, pop/back). Example \u00b6 Testing a Circuit Presenter and UI is a breeze! Consider the following example: data class Favorite ( id : Long , ...) @Parcelable object FavoritesScreen : Screen { sealed interface State : CircuitUiState { object Loading : State object NoFavorites : State data class Results ( val list : List < Favorite > , val eventSink : ( Event ) -> Unit ) : State } sealed interface Event : CircuitUiEvent { data class ClickFavorite ( id : Long ): Event } } class FavoritesPresenter @Inject constructor ( navigator : Navigator , repo : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { val favorites by produceState < List < Favorites >?> ( null ) { value = repo . getFavorites () } return when { favorites == null -> Loading favorites . isEmpty () -> NoFavorites else -> Results ( favorites ) { event -> when ( event ) { is ClickFavorite -> navigator . goTo ( FavoriteScreen ( event . id )) } } } } } @Composable fun FavoritesList ( state : FavoritesScreen . State ) { when ( state ) { Loading -> Text ( text = stringResource ( R . string . loading_favorites )) NoFavorites -> Text ( modifier = Modifier . testTag ( \"no favorites\" ), text = stringResource ( R . string . no_favorites ) ) is Results -> { Text ( text = \"Your Favorites\" ) LazyColumn { items ( state . list ) { Favorite ( it , state . eventSink ) } } } } } @Composable private fun Favorite ( favorite : Favorite , eventSink : ( FavoritesScreen . Event ) -> Unit ) { Row ( modifier = Modifier . testTag ( \"favorite\" ), onClick = { eventSink ( ClickFavorite ( favorite . id )) } ) { Image ( drawable = favorite . drawable , contentDescription = stringResource ( R . string . favorite_image_desc ) ) Text ( text = favorite . name ) Text ( text = favorite . date ) } } Presenter Unit Tests \u00b6 Here\u2019s a test to verify presenter emissions using the Presenter.test() helper. This function acts as a shorthand over Molecule + Turbine to give you a ReceiveTurbine.() -> Unit lambda. @Test fun `present - emit loading state then list of favorites` () = runTest { val favorites = listOf ( Favorite ( 1L , ...)) val repo = TestFavoritesRepository ( favorites ) val presenter = PetListPresenter ( navigator , repo ) presenter . test { assertThat ( awaitItem ()). isEqualTo ( PetListScreen . State . Loading ) val resultsItem = awaitItem () as Results assertThat ( resultsItem . favorites ). isEqualTo ( favorites ) } } The same helper can be used when testing how the presenter responds to incoming events : @Test fun `present - navigate to favorite screen` () = runTest { val repo = TestFavoritesRepository ( Favorite ( 123L )) val presenter = PetListPresenter ( navigator , repo ) presenter . test { assertThat ( awaitItem ()). isEqualTo ( PetListScreen . State . Loading ) val resultsItem = awaitItem () as Results assertThat ( resultsItem . favorites ). isEqualTo ( favorites ) val clickFavorite = FavoriteScreen . Event . ClickFavorite ( 123L ) // simulate user tapping favorite in UI resultsItem . eventSink ( clickFavorite ) assertThat ( navigator . awaitNextScreen ()). isEqualTo ( FavoriteScreen ( clickFavorite . id )) } } Android UI Instrumentation Tests \u00b6 UI tests can be driven directly through ComposeTestRule and use its Espresso-esque API for assertions: @Test fun favoritesList_show_favorites_for_result_state () = runTest { val favorites = listOf ( Favorite ( 1L , ...) composeTestRule . run { setContent { // bootstrap the UI in the desired state FavoritesList ( state = FavoriteScreen . State . Results ( favorites ) { /* event callback */ } ) } onNodeWithTag ( \"no favorites\" ). assertDoesNotExist () onNodeWithText ( \"Your Favorites\" ). assertIsDisplayed () onAllNodesWithTag ( \"favorite\" ). assertCountEquals ( 1 ) } } Future: Android UI Unit Tests via Paparazzi \u00b6 We\u2019ve started exploring use of Paparazzi , which allows us to render Android UI without a physical device or emulator. More to come soon, but in short it would work similar to the above but be for purely non-functional 1:1 state \u2194 UI tests. @Test fun previewFavorite () { paparazzi . snapshot { PreviewFavorite () } } These are easy to maintain and review in GitHub. Another neat idea is we think this will make it easy to stand up compose preview functions for IDE use and reuse them. // In your main source @Preview @Composable internal fun PreviewFavorite () { Favorite () } // In your unit test @Test fun previewFavorite () { paparazzi . snapshot { PreviewFavorite () } }","title":"Testing"},{"location":"testing/#testing","text":"Circuit is designed to make testing as easy as possible. Its core components are not mockable nor do they need to be mocked. Fakes are provided where needed, everything else can be used directly. Circuit will have a test artifact containing APIs to aid testing both presenters and composable UIs: Presenter.test() - an extension function that bridges the Compose and coroutines world. Use of this function is recommended for testing presenter state emissions and incoming UI events. Under the hood it leverages Molecule and Turbine . FakeNavigator - a test fake implementing the Circuit/Navigator interface. Use of this object is recommended when testing screen navigation (ie. goTo, pop/back).","title":"Testing"},{"location":"testing/#example","text":"Testing a Circuit Presenter and UI is a breeze! Consider the following example: data class Favorite ( id : Long , ...) @Parcelable object FavoritesScreen : Screen { sealed interface State : CircuitUiState { object Loading : State object NoFavorites : State data class Results ( val list : List < Favorite > , val eventSink : ( Event ) -> Unit ) : State } sealed interface Event : CircuitUiEvent { data class ClickFavorite ( id : Long ): Event } } class FavoritesPresenter @Inject constructor ( navigator : Navigator , repo : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { val favorites by produceState < List < Favorites >?> ( null ) { value = repo . getFavorites () } return when { favorites == null -> Loading favorites . isEmpty () -> NoFavorites else -> Results ( favorites ) { event -> when ( event ) { is ClickFavorite -> navigator . goTo ( FavoriteScreen ( event . id )) } } } } } @Composable fun FavoritesList ( state : FavoritesScreen . State ) { when ( state ) { Loading -> Text ( text = stringResource ( R . string . loading_favorites )) NoFavorites -> Text ( modifier = Modifier . testTag ( \"no favorites\" ), text = stringResource ( R . string . no_favorites ) ) is Results -> { Text ( text = \"Your Favorites\" ) LazyColumn { items ( state . list ) { Favorite ( it , state . eventSink ) } } } } } @Composable private fun Favorite ( favorite : Favorite , eventSink : ( FavoritesScreen . Event ) -> Unit ) { Row ( modifier = Modifier . testTag ( \"favorite\" ), onClick = { eventSink ( ClickFavorite ( favorite . id )) } ) { Image ( drawable = favorite . drawable , contentDescription = stringResource ( R . string . favorite_image_desc ) ) Text ( text = favorite . name ) Text ( text = favorite . date ) } }","title":"Example"},{"location":"testing/#presenter-unit-tests","text":"Here\u2019s a test to verify presenter emissions using the Presenter.test() helper. This function acts as a shorthand over Molecule + Turbine to give you a ReceiveTurbine.() -> Unit lambda. @Test fun `present - emit loading state then list of favorites` () = runTest { val favorites = listOf ( Favorite ( 1L , ...)) val repo = TestFavoritesRepository ( favorites ) val presenter = PetListPresenter ( navigator , repo ) presenter . test { assertThat ( awaitItem ()). isEqualTo ( PetListScreen . State . Loading ) val resultsItem = awaitItem () as Results assertThat ( resultsItem . favorites ). isEqualTo ( favorites ) } } The same helper can be used when testing how the presenter responds to incoming events : @Test fun `present - navigate to favorite screen` () = runTest { val repo = TestFavoritesRepository ( Favorite ( 123L )) val presenter = PetListPresenter ( navigator , repo ) presenter . test { assertThat ( awaitItem ()). isEqualTo ( PetListScreen . State . Loading ) val resultsItem = awaitItem () as Results assertThat ( resultsItem . favorites ). isEqualTo ( favorites ) val clickFavorite = FavoriteScreen . Event . ClickFavorite ( 123L ) // simulate user tapping favorite in UI resultsItem . eventSink ( clickFavorite ) assertThat ( navigator . awaitNextScreen ()). isEqualTo ( FavoriteScreen ( clickFavorite . id )) } }","title":"Presenter Unit Tests"},{"location":"testing/#android-ui-instrumentation-tests","text":"UI tests can be driven directly through ComposeTestRule and use its Espresso-esque API for assertions: @Test fun favoritesList_show_favorites_for_result_state () = runTest { val favorites = listOf ( Favorite ( 1L , ...) composeTestRule . run { setContent { // bootstrap the UI in the desired state FavoritesList ( state = FavoriteScreen . State . Results ( favorites ) { /* event callback */ } ) } onNodeWithTag ( \"no favorites\" ). assertDoesNotExist () onNodeWithText ( \"Your Favorites\" ). assertIsDisplayed () onAllNodesWithTag ( \"favorite\" ). assertCountEquals ( 1 ) } }","title":"Android UI Instrumentation Tests"},{"location":"testing/#future-android-ui-unit-tests-via-paparazzi","text":"We\u2019ve started exploring use of Paparazzi , which allows us to render Android UI without a physical device or emulator. More to come soon, but in short it would work similar to the above but be for purely non-functional 1:1 state \u2194 UI tests. @Test fun previewFavorite () { paparazzi . snapshot { PreviewFavorite () } } These are easy to maintain and review in GitHub. Another neat idea is we think this will make it easy to stand up compose preview functions for IDE use and reuse them. // In your main source @Preview @Composable internal fun PreviewFavorite () { Favorite () } // In your unit test @Test fun previewFavorite () { paparazzi . snapshot { PreviewFavorite () } }","title":"Future: Android UI Unit Tests via Paparazzi"},{"location":"ui/","text":"UI \u00b6 The core Ui interface is simply this: interface Ui < UiState : CircuitUiState > { @Composable fun Content ( state : UiState ) } Like presenters, simple UIs can also skip the class all together for use in other UIs. Core unit of granularity is just the @Composable function. In fact, when implementing these in practice they rarely use dependency injection at all and can normally just be written as top-level composable functions annotated with @CircuitInject . @CircuitInject < FavoritesScreen > // Relevant DI wiring is generated @Composable private fun Favorites ( state : FavoritesState ) { // ... } Writing UIs like this has a number of benefits. Functions-only nudges developers toward writing idiomatic compose code and not keeping un-scoped/un-observable state elsewhere (such as class properties). These functions are extremely easy to stand up in tests. These functions are extremely easy to stand up in Compose preview functions. Let\u2019s look a little more closely at the last bullet point about preview functions. With the above example, we can easily stand up previews for all of our different states! @Preview @Composable private fun PreviewFavorites () = Favorites ( FavoritesState ( listOf ( \"Reeses\" , \"Lola\" )) @Preview @Composable private fun PreviewEmptyFavorites () = Favorites ( FavoritesState ( listOf ()) TODO image sample of IDE preview","title":"Ui"},{"location":"ui/#ui","text":"The core Ui interface is simply this: interface Ui < UiState : CircuitUiState > { @Composable fun Content ( state : UiState ) } Like presenters, simple UIs can also skip the class all together for use in other UIs. Core unit of granularity is just the @Composable function. In fact, when implementing these in practice they rarely use dependency injection at all and can normally just be written as top-level composable functions annotated with @CircuitInject . @CircuitInject < FavoritesScreen > // Relevant DI wiring is generated @Composable private fun Favorites ( state : FavoritesState ) { // ... } Writing UIs like this has a number of benefits. Functions-only nudges developers toward writing idiomatic compose code and not keeping un-scoped/un-observable state elsewhere (such as class properties). These functions are extremely easy to stand up in tests. These functions are extremely easy to stand up in Compose preview functions. Let\u2019s look a little more closely at the last bullet point about preview functions. With the above example, we can easily stand up previews for all of our different states! @Preview @Composable private fun PreviewFavorites () = Favorites ( FavoritesState ( listOf ( \"Reeses\" , \"Lola\" )) @Preview @Composable private fun PreviewEmptyFavorites () = Favorites ( FavoritesState ( listOf ()) TODO image sample of IDE preview","title":"UI"},{"location":"api/0.x/","text":"// circuit circuit \u00b6 Packages \u00b6 Name com.slack.circuit","title":"Index"},{"location":"api/0.x/#circuit","text":"","title":"circuit"},{"location":"api/0.x/#packages","text":"Name com.slack.circuit","title":"Packages"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/","text":"// backstack / com.slack.circuit.backstack Package com.slack.circuit.backstack \u00b6 Types \u00b6 Name Summary BackStack [common] @ Stable interface BackStack < R : BackStack.Record > : Iterable < R > A caller-supplied stack of Record s for presentation with the Navigator composable. Iteration order is top-first (first element is the top of the stack). BackStackRecordLocalProvider [common] fun interface BackStackRecordLocalProvider <in R : BackStack.Record > BackStackRecordLocalProviderViewModel [android] class BackStackRecordLocalProviderViewModel : ViewModel NavDecoration [android] @ Stable interface NavDecoration Presentation logic for currently visible routes of a navigable UI. NavigatorDefaults [android] object NavigatorDefaults Default values and common alternatives used by navigable composables. ProvidedValues [common] fun interface ProvidedValues SaveableBackStack [android] class SaveableBackStack : BackStack< SaveableBackStack.Record > A BackStack that supports saving its state via rememberSaveable . See rememberSaveableBackStack . SaveableStateRegistryBackStackRecordLocalProvider [android] object SaveableStateRegistryBackStackRecordLocalProvider : BackStackRecordLocalProvider<BackStack.Record> A BackStackRecordLocalProvider that provides a SaveableStateRegistry for each record. Functions \u00b6 Name Summary popUntil [android] inline fun SaveableBackStack . popUntil (predicate: ( SaveableBackStack.Record ) -> Boolean ) providedValuesForBackStack [common] @ Composable fun < R : BackStack.Record > providedValuesForBackStack (backStack: BackStack < R >, stackLocalProviders: List < BackStackRecordLocalProvider < R >> = emptyList(), includeDefaults: Boolean = true): Map < R , ProvidedValues > push [android] fun SaveableBackStack . push (route: String , args: Map < String , Any ?> = emptyMap()) rememberSaveableBackStack [android] @ Composable fun rememberSaveableBackStack (init: SaveableBackStack .() -> Unit ): SaveableBackStack Properties \u00b6 Name Summary isAtRoot [common] val BackStack <*>. isAtRoot : Boolean true if the BackStack contains exactly one record. isEmpty [common] val BackStack <*>. isEmpty : Boolean true if the BackStack contains no records. BackStack.firstOrNull will return null .","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/#package-comslackcircuitbackstack","text":"","title":"Package com.slack.circuit.backstack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/#types","text":"Name Summary BackStack [common] @ Stable interface BackStack < R : BackStack.Record > : Iterable < R > A caller-supplied stack of Record s for presentation with the Navigator composable. Iteration order is top-first (first element is the top of the stack). BackStackRecordLocalProvider [common] fun interface BackStackRecordLocalProvider <in R : BackStack.Record > BackStackRecordLocalProviderViewModel [android] class BackStackRecordLocalProviderViewModel : ViewModel NavDecoration [android] @ Stable interface NavDecoration Presentation logic for currently visible routes of a navigable UI. NavigatorDefaults [android] object NavigatorDefaults Default values and common alternatives used by navigable composables. ProvidedValues [common] fun interface ProvidedValues SaveableBackStack [android] class SaveableBackStack : BackStack< SaveableBackStack.Record > A BackStack that supports saving its state via rememberSaveable . See rememberSaveableBackStack . SaveableStateRegistryBackStackRecordLocalProvider [android] object SaveableStateRegistryBackStackRecordLocalProvider : BackStackRecordLocalProvider<BackStack.Record> A BackStackRecordLocalProvider that provides a SaveableStateRegistry for each record.","title":"Types"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/#functions","text":"Name Summary popUntil [android] inline fun SaveableBackStack . popUntil (predicate: ( SaveableBackStack.Record ) -> Boolean ) providedValuesForBackStack [common] @ Composable fun < R : BackStack.Record > providedValuesForBackStack (backStack: BackStack < R >, stackLocalProviders: List < BackStackRecordLocalProvider < R >> = emptyList(), includeDefaults: Boolean = true): Map < R , ProvidedValues > push [android] fun SaveableBackStack . push (route: String , args: Map < String , Any ?> = emptyMap()) rememberSaveableBackStack [android] @ Composable fun rememberSaveableBackStack (init: SaveableBackStack .() -> Unit ): SaveableBackStack","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/#properties","text":"Name Summary isAtRoot [common] val BackStack <*>. isAtRoot : Boolean true if the BackStack contains exactly one record. isEmpty [common] val BackStack <*>. isEmpty : Boolean true if the BackStack contains no records. BackStack.firstOrNull will return null .","title":"Properties"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/is-at-root/","text":"// backstack / com.slack.circuit.backstack / isAtRoot isAtRoot \u00b6 [common]\\ val BackStack <*>. isAtRoot : Boolean true if the BackStack contains exactly one record.","title":"Is at root"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/is-at-root/#isatroot","text":"[common]\\ val BackStack <*>. isAtRoot : Boolean true if the BackStack contains exactly one record.","title":"isAtRoot"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/is-empty/","text":"// backstack / com.slack.circuit.backstack / isEmpty isEmpty \u00b6 [common]\\ val BackStack <*>. isEmpty : Boolean true if the BackStack contains no records. BackStack.firstOrNull will return null .","title":"Is empty"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/is-empty/#isempty","text":"[common]\\ val BackStack <*>. isEmpty : Boolean true if the BackStack contains no records. BackStack.firstOrNull will return null .","title":"isEmpty"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/pop-until/","text":"// backstack / com.slack.circuit.backstack / popUntil popUntil \u00b6 [android]\\ inline fun SaveableBackStack . popUntil (predicate: ( SaveableBackStack.Record ) -> Boolean )","title":"Pop until"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/pop-until/#popuntil","text":"[android]\\ inline fun SaveableBackStack . popUntil (predicate: ( SaveableBackStack.Record ) -> Boolean )","title":"popUntil"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/provided-values-for-back-stack/","text":"// backstack / com.slack.circuit.backstack / providedValuesForBackStack providedValuesForBackStack \u00b6 [common]\\ @ Composable fun < R : BackStack.Record > providedValuesForBackStack (backStack: BackStack < R >, stackLocalProviders: List < BackStackRecordLocalProvider < R >> = emptyList(), includeDefaults: Boolean = true): Map < R , ProvidedValues >","title":"Provided values for back stack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/provided-values-for-back-stack/#providedvaluesforbackstack","text":"[common]\\ @ Composable fun < R : BackStack.Record > providedValuesForBackStack (backStack: BackStack < R >, stackLocalProviders: List < BackStackRecordLocalProvider < R >> = emptyList(), includeDefaults: Boolean = true): Map < R , ProvidedValues >","title":"providedValuesForBackStack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/push/","text":"// backstack / com.slack.circuit.backstack / push push \u00b6 [android]\\ fun SaveableBackStack . push (route: String , args: Map < String , Any ?> = emptyMap())","title":"Push"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/push/#push","text":"[android]\\ fun SaveableBackStack . push (route: String , args: Map < String , Any ?> = emptyMap())","title":"push"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/remember-saveable-back-stack/","text":"// backstack / com.slack.circuit.backstack / rememberSaveableBackStack rememberSaveableBackStack \u00b6 [android]\\ @ Composable fun rememberSaveableBackStack (init: SaveableBackStack .() -> Unit ): SaveableBackStack","title":"Remember saveable back stack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/remember-saveable-back-stack/#remembersaveablebackstack","text":"[android]\\ @ Composable fun rememberSaveableBackStack (init: SaveableBackStack .() -> Unit ): SaveableBackStack","title":"rememberSaveableBackStack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/","text":"// backstack / com.slack.circuit.backstack / BackStack BackStack \u00b6 [common]\\ @ Stable interface BackStack < R : BackStack.Record > : Iterable < R > A caller-supplied stack of Record s for presentation with the Navigator composable. Iteration order is top-first (first element is the top of the stack). Types \u00b6 Name Summary Record [common] interface Record Functions \u00b6 Name Summary iterator [common] abstract operator fun iterator (): Iterator < R > pop [common] abstract fun pop (): R ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped. Properties \u00b6 Name Summary size [common] abstract val size : Int The number of records contained in this BackStack that will be seen by an iterator. Inheritors \u00b6 Name SaveableBackStack Extensions \u00b6 Name Summary isAtRoot [common] val BackStack <*>. isAtRoot : Boolean true if the BackStack contains exactly one record. isEmpty [common] val BackStack <*>. isEmpty : Boolean true if the BackStack contains no records. BackStack.firstOrNull will return null .","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#backstack","text":"[common]\\ @ Stable interface BackStack < R : BackStack.Record > : Iterable < R > A caller-supplied stack of Record s for presentation with the Navigator composable. Iteration order is top-first (first element is the top of the stack).","title":"BackStack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#types","text":"Name Summary Record [common] interface Record","title":"Types"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#functions","text":"Name Summary iterator [common] abstract operator fun iterator (): Iterator < R > pop [common] abstract fun pop (): R ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped.","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#properties","text":"Name Summary size [common] abstract val size : Int The number of records contained in this BackStack that will be seen by an iterator.","title":"Properties"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#inheritors","text":"Name SaveableBackStack","title":"Inheritors"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#extensions","text":"Name Summary isAtRoot [common] val BackStack <*>. isAtRoot : Boolean true if the BackStack contains exactly one record. isEmpty [common] val BackStack <*>. isEmpty : Boolean true if the BackStack contains no records. BackStack.firstOrNull will return null .","title":"Extensions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/pop/","text":"// backstack / com.slack.circuit.backstack / BackStack / pop pop \u00b6 [common]\\ abstract fun pop (): R ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped.","title":"Pop"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/pop/#pop","text":"[common]\\ abstract fun pop (): R ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped.","title":"pop"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/size/","text":"// backstack / com.slack.circuit.backstack / BackStack / size size \u00b6 [common]\\ abstract val size : Int The number of records contained in this BackStack that will be seen by an iterator.","title":"Size"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/size/#size","text":"[common]\\ abstract val size : Int The number of records contained in this BackStack that will be seen by an iterator.","title":"size"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/","text":"// backstack / com.slack.circuit.backstack / BackStack / Record Record \u00b6 [common]\\ interface Record Properties \u00b6 Name Summary key [common] abstract val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProvider s to associate presentation data with a record across composition recreation. route [common] abstract val route : String The name of the route that should present this record. Inheritors \u00b6 Name Record","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/#record","text":"[common]\\ interface Record","title":"Record"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/#properties","text":"Name Summary key [common] abstract val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProvider s to associate presentation data with a record across composition recreation. route [common] abstract val route : String The name of the route that should present this record.","title":"Properties"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/#inheritors","text":"Name Record","title":"Inheritors"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/key/","text":"// backstack / com.slack.circuit.backstack / BackStack / Record / key key \u00b6 [common]\\ abstract val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProvider s to associate presentation data with a record across composition recreation. key MUST NOT change for the life of the record.","title":"Key"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/key/#key","text":"[common]\\ abstract val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProvider s to associate presentation data with a record across composition recreation. key MUST NOT change for the life of the record.","title":"key"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/route/","text":"// backstack / com.slack.circuit.backstack / BackStack / Record / route route \u00b6 [common]\\ abstract val route : String The name of the route that should present this record.","title":"Route"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/route/#route","text":"[common]\\ abstract val route : String The name of the route that should present this record.","title":"route"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/","text":"// backstack / com.slack.circuit.backstack / BackStackRecordLocalProvider BackStackRecordLocalProvider \u00b6 [common]\\ fun interface BackStackRecordLocalProvider <in R : BackStack.Record > Functions \u00b6 Name Summary providedValuesFor [common] @ Composable abstract fun providedValuesFor (record: R ): ProvidedValues Inheritors \u00b6 Name SaveableStateRegistryBackStackRecordLocalProvider","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/#backstackrecordlocalprovider","text":"[common]\\ fun interface BackStackRecordLocalProvider <in R : BackStack.Record >","title":"BackStackRecordLocalProvider"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/#functions","text":"Name Summary providedValuesFor [common] @ Composable abstract fun providedValuesFor (record: R ): ProvidedValues","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/#inheritors","text":"Name SaveableStateRegistryBackStackRecordLocalProvider","title":"Inheritors"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/provided-values-for/","text":"// backstack / com.slack.circuit.backstack / BackStackRecordLocalProvider / providedValuesFor providedValuesFor \u00b6 [common]\\ @ Composable abstract fun providedValuesFor (record: R ): ProvidedValues","title":"Provided values for"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/provided-values-for/#providedvaluesfor","text":"[common]\\ @ Composable abstract fun providedValuesFor (record: R ): ProvidedValues","title":"providedValuesFor"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider-view-model/","text":"// backstack / com.slack.circuit.backstack / BackStackRecordLocalProviderViewModel BackStackRecordLocalProviderViewModel \u00b6 [android]\\ class BackStackRecordLocalProviderViewModel : ViewModel Constructors \u00b6 BackStackRecordLocalProviderViewModel [android] fun BackStackRecordLocalProviderViewModel () Functions \u00b6 Name Summary addCloseable [android] open fun addCloseable (@ NonNull p0: Closeable )","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider-view-model/#backstackrecordlocalproviderviewmodel","text":"[android]\\ class BackStackRecordLocalProviderViewModel : ViewModel","title":"BackStackRecordLocalProviderViewModel"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider-view-model/#constructors","text":"BackStackRecordLocalProviderViewModel [android] fun BackStackRecordLocalProviderViewModel ()","title":"Constructors"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider-view-model/#functions","text":"Name Summary addCloseable [android] open fun addCloseable (@ NonNull p0: Closeable )","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider-view-model/-back-stack-record-local-provider-view-model/","text":"// backstack / com.slack.circuit.backstack / BackStackRecordLocalProviderViewModel / BackStackRecordLocalProviderViewModel BackStackRecordLocalProviderViewModel \u00b6 [android]\\ fun BackStackRecordLocalProviderViewModel ()","title":" back stack record local provider view model"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider-view-model/-back-stack-record-local-provider-view-model/#backstackrecordlocalproviderviewmodel","text":"[android]\\ fun BackStackRecordLocalProviderViewModel ()","title":"BackStackRecordLocalProviderViewModel"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/","text":"// backstack / com.slack.circuit.backstack / NavDecoration NavDecoration \u00b6 [android]\\ @ Stable interface NavDecoration Presentation logic for currently visible routes of a navigable UI. Functions \u00b6 Name Summary DecoratedContent [android] @ Composable abstract fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit ) Inheritors \u00b6 Name DefaultDecoration EmptyDecoration","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/#navdecoration","text":"[android]\\ @ Stable interface NavDecoration Presentation logic for currently visible routes of a navigable UI.","title":"NavDecoration"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/#functions","text":"Name Summary DecoratedContent [android] @ Composable abstract fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/#inheritors","text":"Name DefaultDecoration EmptyDecoration","title":"Inheritors"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/-decorated-content/","text":"// backstack / com.slack.circuit.backstack / NavDecoration / DecoratedContent DecoratedContent \u00b6 [android]\\ @ Composable abstract fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":" decorated content"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/-decorated-content/#decoratedcontent","text":"[android]\\ @ Composable abstract fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"DecoratedContent"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/","text":"// backstack / com.slack.circuit.backstack / NavigatorDefaults NavigatorDefaults \u00b6 [android]\\ object NavigatorDefaults Default values and common alternatives used by navigable composables. Types \u00b6 Name Summary DefaultDecoration [android] object DefaultDecoration : NavDecoration The default NavDecoration used in navigation. EmptyDecoration [android] object EmptyDecoration : NavDecoration An empty NavDecoration that emits the content with no surrounding decoration or logic. Properties \u00b6 Name Summary UnavailableRoute [android] val UnavailableRoute : @ Composable ( String ) -> Unit Bright ugly error text telling a developer they didn\u2019t provide a route that a BackStack asked for.","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/#navigatordefaults","text":"[android]\\ object NavigatorDefaults Default values and common alternatives used by navigable composables.","title":"NavigatorDefaults"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/#types","text":"Name Summary DefaultDecoration [android] object DefaultDecoration : NavDecoration The default NavDecoration used in navigation. EmptyDecoration [android] object EmptyDecoration : NavDecoration An empty NavDecoration that emits the content with no surrounding decoration or logic.","title":"Types"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/#properties","text":"Name Summary UnavailableRoute [android] val UnavailableRoute : @ Composable ( String ) -> Unit Bright ugly error text telling a developer they didn\u2019t provide a route that a BackStack asked for.","title":"Properties"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/-unavailable-route/","text":"// backstack / com.slack.circuit.backstack / NavigatorDefaults / UnavailableRoute UnavailableRoute \u00b6 [android]\\ val UnavailableRoute : @ Composable ( String ) -> Unit Bright ugly error text telling a developer they didn\u2019t provide a route that a BackStack asked for.","title":" unavailable route"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/-unavailable-route/#unavailableroute","text":"[android]\\ val UnavailableRoute : @ Composable ( String ) -> Unit Bright ugly error text telling a developer they didn\u2019t provide a route that a BackStack asked for.","title":"UnavailableRoute"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/-default-decoration/","text":"// backstack / com.slack.circuit.backstack / NavigatorDefaults / DefaultDecoration DefaultDecoration \u00b6 [android]\\ object DefaultDecoration : NavDecoration The default NavDecoration used in navigation. Functions \u00b6 Name Summary DecoratedContent [android] @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/-default-decoration/#defaultdecoration","text":"[android]\\ object DefaultDecoration : NavDecoration The default NavDecoration used in navigation.","title":"DefaultDecoration"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/-default-decoration/#functions","text":"Name Summary DecoratedContent [android] @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/-default-decoration/-decorated-content/","text":"// backstack / com.slack.circuit.backstack / NavigatorDefaults / DefaultDecoration / DecoratedContent DecoratedContent \u00b6 [android]\\ @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":" decorated content"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/-default-decoration/-decorated-content/#decoratedcontent","text":"[android]\\ @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"DecoratedContent"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/-empty-decoration/","text":"// backstack / com.slack.circuit.backstack / NavigatorDefaults / EmptyDecoration EmptyDecoration \u00b6 [android]\\ object EmptyDecoration : NavDecoration An empty NavDecoration that emits the content with no surrounding decoration or logic. Functions \u00b6 Name Summary DecoratedContent [android] @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/-empty-decoration/#emptydecoration","text":"[android]\\ object EmptyDecoration : NavDecoration An empty NavDecoration that emits the content with no surrounding decoration or logic.","title":"EmptyDecoration"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/-empty-decoration/#functions","text":"Name Summary DecoratedContent [android] @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/-empty-decoration/-decorated-content/","text":"// backstack / com.slack.circuit.backstack / NavigatorDefaults / EmptyDecoration / DecoratedContent DecoratedContent \u00b6 [android]\\ @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":" decorated content"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-navigator-defaults/-empty-decoration/-decorated-content/#decoratedcontent","text":"[android]\\ @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"DecoratedContent"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-provided-values/","text":"// backstack / com.slack.circuit.backstack / ProvidedValues ProvidedValues \u00b6 [common]\\ fun interface ProvidedValues Functions \u00b6 Name Summary provideValues [common] @ Composable abstract fun provideValues (): List < ProvidedValue <*>>","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-provided-values/#providedvalues","text":"[common]\\ fun interface ProvidedValues","title":"ProvidedValues"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-provided-values/#functions","text":"Name Summary provideValues [common] @ Composable abstract fun provideValues (): List < ProvidedValue <*>>","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-provided-values/provide-values/","text":"// backstack / com.slack.circuit.backstack / ProvidedValues / provideValues provideValues \u00b6 [common]\\ @ Composable abstract fun provideValues (): List < ProvidedValue <*>>","title":"Provide values"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-provided-values/provide-values/#providevalues","text":"[common]\\ @ Composable abstract fun provideValues (): List < ProvidedValue <*>>","title":"provideValues"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack SaveableBackStack \u00b6 [android]\\ class SaveableBackStack : BackStack< SaveableBackStack.Record > A BackStack that supports saving its state via rememberSaveable . See rememberSaveableBackStack . Constructors \u00b6 SaveableBackStack [android] fun SaveableBackStack () Types \u00b6 Name Summary Record [android] data class Record (val route: String , val args: Map < String , Any ?> = emptyMap(), val key: String = UUID.randomUUID().toString()) : BackStack.Record Functions \u00b6 Name Summary forEach [android] open fun forEach (p0: Consumer <in SaveableBackStack.Record >) iterator [android] open operator override fun iterator (): Iterator < SaveableBackStack.Record > pop [android] open override fun pop (): SaveableBackStack.Record ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped. push [android] fun push (record: SaveableBackStack.Record ) spliterator [android] open fun spliterator (): Spliterator < SaveableBackStack.Record > Properties \u00b6 Name Summary size [android] open override val size : Int The number of records contained in this BackStack that will be seen by an iterator. topRecord [android] val topRecord : SaveableBackStack.Record ? Extensions \u00b6 Name Summary popUntil [android] inline fun SaveableBackStack . popUntil (predicate: ( SaveableBackStack.Record ) -> Boolean ) push [android] fun SaveableBackStack . push (route: String , args: Map < String , Any ?> = emptyMap())","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#saveablebackstack","text":"[android]\\ class SaveableBackStack : BackStack< SaveableBackStack.Record > A BackStack that supports saving its state via rememberSaveable . See rememberSaveableBackStack .","title":"SaveableBackStack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#constructors","text":"SaveableBackStack [android] fun SaveableBackStack ()","title":"Constructors"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#types","text":"Name Summary Record [android] data class Record (val route: String , val args: Map < String , Any ?> = emptyMap(), val key: String = UUID.randomUUID().toString()) : BackStack.Record","title":"Types"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#functions","text":"Name Summary forEach [android] open fun forEach (p0: Consumer <in SaveableBackStack.Record >) iterator [android] open operator override fun iterator (): Iterator < SaveableBackStack.Record > pop [android] open override fun pop (): SaveableBackStack.Record ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped. push [android] fun push (record: SaveableBackStack.Record ) spliterator [android] open fun spliterator (): Spliterator < SaveableBackStack.Record >","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#properties","text":"Name Summary size [android] open override val size : Int The number of records contained in this BackStack that will be seen by an iterator. topRecord [android] val topRecord : SaveableBackStack.Record ?","title":"Properties"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#extensions","text":"Name Summary popUntil [android] inline fun SaveableBackStack . popUntil (predicate: ( SaveableBackStack.Record ) -> Boolean ) push [android] fun SaveableBackStack . push (route: String , args: Map < String , Any ?> = emptyMap())","title":"Extensions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-saveable-back-stack/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / SaveableBackStack SaveableBackStack \u00b6 [android]\\ fun SaveableBackStack ()","title":" saveable back stack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-saveable-back-stack/#saveablebackstack","text":"[android]\\ fun SaveableBackStack ()","title":"SaveableBackStack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/iterator/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / iterator iterator \u00b6 [android]\\ open operator override fun iterator (): Iterator < SaveableBackStack.Record >","title":"Iterator"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/iterator/#iterator","text":"[android]\\ open operator override fun iterator (): Iterator < SaveableBackStack.Record >","title":"iterator"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/pop/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / pop pop \u00b6 [android]\\ open override fun pop (): SaveableBackStack.Record ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped.","title":"Pop"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/pop/#pop","text":"[android]\\ open override fun pop (): SaveableBackStack.Record ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped.","title":"pop"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/push/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / push push \u00b6 [android]\\ fun push (record: SaveableBackStack.Record )","title":"Push"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/push/#push","text":"[android]\\ fun push (record: SaveableBackStack.Record )","title":"push"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/size/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / size size \u00b6 [android]\\ open override val size : Int The number of records contained in this BackStack that will be seen by an iterator.","title":"Size"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/size/#size","text":"[android]\\ open override val size : Int The number of records contained in this BackStack that will be seen by an iterator.","title":"size"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/top-record/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / topRecord topRecord \u00b6 [android]\\ val topRecord : SaveableBackStack.Record ?","title":"Top record"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/top-record/#toprecord","text":"[android]\\ val topRecord : SaveableBackStack.Record ?","title":"topRecord"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / Record Record \u00b6 [android]\\ data class Record (val route: String , val args: Map < String , Any ?> = emptyMap(), val key: String = UUID.randomUUID().toString()) : BackStack.Record Constructors \u00b6 Record [android] fun Record (route: String , args: Map < String , Any ?> = emptyMap(), key: String = UUID.randomUUID().toString()) Properties \u00b6 Name Summary args [android] val args : Map < String , Any ?> key [android] open override val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProviders to associate presentation data with a record across composition recreation. route [android] open override val route : String The name of the route that should present this record.","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/#record","text":"[android]\\ data class Record (val route: String , val args: Map < String , Any ?> = emptyMap(), val key: String = UUID.randomUUID().toString()) : BackStack.Record","title":"Record"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/#constructors","text":"Record [android] fun Record (route: String , args: Map < String , Any ?> = emptyMap(), key: String = UUID.randomUUID().toString())","title":"Constructors"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/#properties","text":"Name Summary args [android] val args : Map < String , Any ?> key [android] open override val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProviders to associate presentation data with a record across composition recreation. route [android] open override val route : String The name of the route that should present this record.","title":"Properties"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/-record/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / Record / Record Record \u00b6 [android]\\ fun Record (route: String , args: Map < String , Any ?> = emptyMap(), key: String = UUID.randomUUID().toString())","title":" record"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/-record/#record","text":"[android]\\ fun Record (route: String , args: Map < String , Any ?> = emptyMap(), key: String = UUID.randomUUID().toString())","title":"Record"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/args/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / Record / args args \u00b6 [android]\\ val args : Map < String , Any ?>","title":"Args"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/args/#args","text":"[android]\\ val args : Map < String , Any ?>","title":"args"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/key/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / Record / key key \u00b6 [android]\\ open override val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProviders to associate presentation data with a record across composition recreation. key MUST NOT change for the life of the record.","title":"Key"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/key/#key","text":"[android]\\ open override val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProviders to associate presentation data with a record across composition recreation. key MUST NOT change for the life of the record.","title":"key"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/route/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / Record / route route \u00b6 [android]\\ open override val route : String The name of the route that should present this record.","title":"Route"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/route/#route","text":"[android]\\ open override val route : String The name of the route that should present this record.","title":"route"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-state-registry-back-stack-record-local-provider/","text":"// backstack / com.slack.circuit.backstack / SaveableStateRegistryBackStackRecordLocalProvider SaveableStateRegistryBackStackRecordLocalProvider \u00b6 [android]\\ object SaveableStateRegistryBackStackRecordLocalProvider : BackStackRecordLocalProvider<BackStack.Record> A BackStackRecordLocalProvider that provides a SaveableStateRegistry for each record. Functions \u00b6 Name Summary providedValuesFor [android] @ Composable open override fun providedValuesFor (record: BackStack.Record): ProvidedValues","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-state-registry-back-stack-record-local-provider/#saveablestateregistrybackstackrecordlocalprovider","text":"[android]\\ object SaveableStateRegistryBackStackRecordLocalProvider : BackStackRecordLocalProvider<BackStack.Record> A BackStackRecordLocalProvider that provides a SaveableStateRegistry for each record.","title":"SaveableStateRegistryBackStackRecordLocalProvider"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-state-registry-back-stack-record-local-provider/#functions","text":"Name Summary providedValuesFor [android] @ Composable open override fun providedValuesFor (record: BackStack.Record): ProvidedValues","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-state-registry-back-stack-record-local-provider/provided-values-for/","text":"// backstack / com.slack.circuit.backstack / SaveableStateRegistryBackStackRecordLocalProvider / providedValuesFor providedValuesFor \u00b6 [android]\\ @ Composable open override fun providedValuesFor (record: BackStack.Record): ProvidedValues","title":"Provided values for"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-state-registry-back-stack-record-local-provider/provided-values-for/#providedvaluesfor","text":"[android]\\ @ Composable open override fun providedValuesFor (record: BackStack.Record): ProvidedValues","title":"providedValuesFor"},{"location":"api/0.x/circuit/com.slack.circuit/","text":"// circuit / com.slack.circuit Package com.slack.circuit \u00b6 Types \u00b6 Name Summary CircuitConfig [common] @ Immutable class CircuitConfig CircuitConfig adapts presenter factories to their corresponding renderable ui factories using screens . Create instances using the Builder and create new CircuitContent with it to run presenter/UI pairings. CircuitUiEvent [common] @ Immutable interface CircuitUiEvent Marker interface for all UiEvent types. CircuitUiState [common] @ Immutable interface CircuitUiState Marker interface for all UiState types. LocalCircuitOwner [common] object LocalCircuitOwner NavEvent [common] interface NavEvent : CircuitUiEvent A sealed navigation interface intended to be used when making a navigation call back. Navigator [common] @ Stable interface Navigator A basic navigation interface for navigating between screens . Presenter [common] interface Presenter < UiState : CircuitUiState > Presents a given UiState . Screen [common] expect interface Screen Represents an individual screen, used as a key for Presenter.Factory and Ui.Factory . [android, jvm] [android] actual interface Screen : Parcelable [jvm] actual interface Screen ScreenUi [common] data class ScreenUi (val ui: Ui <*>) Ui [common] interface Ui < UiState : CircuitUiState > Represents a composable UI for the given UiState . Conventionally, this should just be the return type of a ui function and a thin shim over a \"real\" implementation. Functions \u00b6 Name Summary BasicNavigableCircuitContent [android] @ Composable fun BasicNavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, providedValues: Map <out BackStack.Record, ProvidedValues>, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, decoration: NavDecoration = NavigatorDefaults.EmptyDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute) CircuitCompositionLocals [common] @ Composable fun CircuitCompositionLocals (circuitConfig: CircuitConfig , content: @ Composable () -> Unit ) Provides the given circuitConfig as a CompositionLocal to all composables within content . Also adds any other composition locals that Circuit needs. CircuitContent [common] @ Composable fun CircuitContent (screen: Screen , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent) @ Composable fun CircuitContent (screen: Screen , onNavEvent: (event: NavEvent ) -> Unit , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent) NavigableCircuitContent [android] @ Composable fun NavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, enableBackHandler: Boolean = true, providedValues: Map <out BackStack.Record, ProvidedValues> = providedValuesForBackStack(backstack), decoration: NavDecoration = NavigatorDefaults.DefaultDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute) onNavEvent [common] fun Navigator . onNavEvent (event: NavEvent ) A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvent s from nested Presenter s. popUntil [common] fun Navigator . popUntil (predicate: ( Screen ) -> Boolean ) Calls Navigator.pop until the given predicate is matched or it pops the root. push [android] fun SaveableBackStack. push (screen: Screen ) rememberCircuitNavigator [android] @ Composable fun rememberCircuitNavigator (backstack: SaveableBackStack, onRootPop: () -> Unit ?): Navigator Returns a new Navigator for navigating within CircuitContents. ui [common] inline fun < UiState : CircuitUiState > ui (crossinline body: @ Composable (state: UiState ) -> Unit ): Ui < UiState > Due to this bug in Studio, we can\u2019t write lambda impls of Ui directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Ui a fun interface instead. Properties \u00b6 Name Summary screen [android] val SaveableBackStack.Record. screen : Screen","title":"circuit"},{"location":"api/0.x/circuit/com.slack.circuit/#package-comslackcircuit","text":"","title":"Package com.slack.circuit"},{"location":"api/0.x/circuit/com.slack.circuit/#types","text":"Name Summary CircuitConfig [common] @ Immutable class CircuitConfig CircuitConfig adapts presenter factories to their corresponding renderable ui factories using screens . Create instances using the Builder and create new CircuitContent with it to run presenter/UI pairings. CircuitUiEvent [common] @ Immutable interface CircuitUiEvent Marker interface for all UiEvent types. CircuitUiState [common] @ Immutable interface CircuitUiState Marker interface for all UiState types. LocalCircuitOwner [common] object LocalCircuitOwner NavEvent [common] interface NavEvent : CircuitUiEvent A sealed navigation interface intended to be used when making a navigation call back. Navigator [common] @ Stable interface Navigator A basic navigation interface for navigating between screens . Presenter [common] interface Presenter < UiState : CircuitUiState > Presents a given UiState . Screen [common] expect interface Screen Represents an individual screen, used as a key for Presenter.Factory and Ui.Factory . [android, jvm] [android] actual interface Screen : Parcelable [jvm] actual interface Screen ScreenUi [common] data class ScreenUi (val ui: Ui <*>) Ui [common] interface Ui < UiState : CircuitUiState > Represents a composable UI for the given UiState . Conventionally, this should just be the return type of a ui function and a thin shim over a \"real\" implementation.","title":"Types"},{"location":"api/0.x/circuit/com.slack.circuit/#functions","text":"Name Summary BasicNavigableCircuitContent [android] @ Composable fun BasicNavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, providedValues: Map <out BackStack.Record, ProvidedValues>, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, decoration: NavDecoration = NavigatorDefaults.EmptyDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute) CircuitCompositionLocals [common] @ Composable fun CircuitCompositionLocals (circuitConfig: CircuitConfig , content: @ Composable () -> Unit ) Provides the given circuitConfig as a CompositionLocal to all composables within content . Also adds any other composition locals that Circuit needs. CircuitContent [common] @ Composable fun CircuitContent (screen: Screen , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent) @ Composable fun CircuitContent (screen: Screen , onNavEvent: (event: NavEvent ) -> Unit , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent) NavigableCircuitContent [android] @ Composable fun NavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, enableBackHandler: Boolean = true, providedValues: Map <out BackStack.Record, ProvidedValues> = providedValuesForBackStack(backstack), decoration: NavDecoration = NavigatorDefaults.DefaultDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute) onNavEvent [common] fun Navigator . onNavEvent (event: NavEvent ) A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvent s from nested Presenter s. popUntil [common] fun Navigator . popUntil (predicate: ( Screen ) -> Boolean ) Calls Navigator.pop until the given predicate is matched or it pops the root. push [android] fun SaveableBackStack. push (screen: Screen ) rememberCircuitNavigator [android] @ Composable fun rememberCircuitNavigator (backstack: SaveableBackStack, onRootPop: () -> Unit ?): Navigator Returns a new Navigator for navigating within CircuitContents. ui [common] inline fun < UiState : CircuitUiState > ui (crossinline body: @ Composable (state: UiState ) -> Unit ): Ui < UiState > Due to this bug in Studio, we can\u2019t write lambda impls of Ui directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Ui a fun interface instead.","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/#properties","text":"Name Summary screen [android] val SaveableBackStack.Record. screen : Screen","title":"Properties"},{"location":"api/0.x/circuit/com.slack.circuit/-basic-navigable-circuit-content/","text":"// circuit / com.slack.circuit / BasicNavigableCircuitContent BasicNavigableCircuitContent \u00b6 [android]\\ @ Composable fun BasicNavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, providedValues: Map <out BackStack.Record, ProvidedValues>, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, decoration: NavDecoration = NavigatorDefaults.EmptyDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute)","title":" basic navigable circuit content"},{"location":"api/0.x/circuit/com.slack.circuit/-basic-navigable-circuit-content/#basicnavigablecircuitcontent","text":"[android]\\ @ Composable fun BasicNavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, providedValues: Map <out BackStack.Record, ProvidedValues>, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, decoration: NavDecoration = NavigatorDefaults.EmptyDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute)","title":"BasicNavigableCircuitContent"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-composition-locals/","text":"// circuit / com.slack.circuit / CircuitCompositionLocals CircuitCompositionLocals \u00b6 [common]\\ @ Composable fun CircuitCompositionLocals (circuitConfig: CircuitConfig , content: @ Composable () -> Unit ) Provides the given circuitConfig as a CompositionLocal to all composables within content . Also adds any other composition locals that Circuit needs.","title":" circuit composition locals"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-composition-locals/#circuitcompositionlocals","text":"[common]\\ @ Composable fun CircuitCompositionLocals (circuitConfig: CircuitConfig , content: @ Composable () -> Unit ) Provides the given circuitConfig as a CompositionLocal to all composables within content . Also adds any other composition locals that Circuit needs.","title":"CircuitCompositionLocals"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-content/","text":"// circuit / com.slack.circuit / CircuitContent CircuitContent \u00b6 [common]\\ @ Composable fun CircuitContent (screen: Screen , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent) @ Composable fun CircuitContent (screen: Screen , onNavEvent: (event: NavEvent ) -> Unit , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent)","title":" circuit content"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-content/#circuitcontent","text":"[common]\\ @ Composable fun CircuitContent (screen: Screen , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent) @ Composable fun CircuitContent (screen: Screen , onNavEvent: (event: NavEvent ) -> Unit , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent)","title":"CircuitContent"},{"location":"api/0.x/circuit/com.slack.circuit/-navigable-circuit-content/","text":"// circuit / com.slack.circuit / NavigableCircuitContent NavigableCircuitContent \u00b6 [android]\\ @ Composable fun NavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, enableBackHandler: Boolean = true, providedValues: Map <out BackStack.Record, ProvidedValues> = providedValuesForBackStack(backstack), decoration: NavDecoration = NavigatorDefaults.DefaultDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute)","title":" navigable circuit content"},{"location":"api/0.x/circuit/com.slack.circuit/-navigable-circuit-content/#navigablecircuitcontent","text":"[android]\\ @ Composable fun NavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, enableBackHandler: Boolean = true, providedValues: Map <out BackStack.Record, ProvidedValues> = providedValuesForBackStack(backstack), decoration: NavDecoration = NavigatorDefaults.DefaultDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute)","title":"NavigableCircuitContent"},{"location":"api/0.x/circuit/com.slack.circuit/on-nav-event/","text":"// circuit / com.slack.circuit / onNavEvent onNavEvent \u00b6 [common]\\ fun Navigator . onNavEvent (event: NavEvent ) A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvent s from nested Presenter s.","title":"On nav event"},{"location":"api/0.x/circuit/com.slack.circuit/on-nav-event/#onnavevent","text":"[common]\\ fun Navigator . onNavEvent (event: NavEvent ) A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvent s from nested Presenter s.","title":"onNavEvent"},{"location":"api/0.x/circuit/com.slack.circuit/pop-until/","text":"// circuit / com.slack.circuit / popUntil popUntil \u00b6 [common]\\ fun Navigator . popUntil (predicate: ( Screen ) -> Boolean ) Calls Navigator.pop until the given predicate is matched or it pops the root.","title":"Pop until"},{"location":"api/0.x/circuit/com.slack.circuit/pop-until/#popuntil","text":"[common]\\ fun Navigator . popUntil (predicate: ( Screen ) -> Boolean ) Calls Navigator.pop until the given predicate is matched or it pops the root.","title":"popUntil"},{"location":"api/0.x/circuit/com.slack.circuit/push/","text":"// circuit / com.slack.circuit / push push \u00b6 [android]\\ fun SaveableBackStack. push (screen: Screen )","title":"Push"},{"location":"api/0.x/circuit/com.slack.circuit/push/#push","text":"[android]\\ fun SaveableBackStack. push (screen: Screen )","title":"push"},{"location":"api/0.x/circuit/com.slack.circuit/remember-circuit-navigator/","text":"// circuit / com.slack.circuit / rememberCircuitNavigator rememberCircuitNavigator \u00b6 [android]\\ @ Composable fun rememberCircuitNavigator (backstack: SaveableBackStack, onRootPop: () -> Unit ?): Navigator Returns a new Navigator for navigating within CircuitContents. See also \u00b6 android NavigableCircuitContent Parameters \u00b6 android backstack The backing SaveableBackStack to navigate. onRootPop The callback to handle root Navigator.pop calls.","title":"Remember circuit navigator"},{"location":"api/0.x/circuit/com.slack.circuit/remember-circuit-navigator/#remembercircuitnavigator","text":"[android]\\ @ Composable fun rememberCircuitNavigator (backstack: SaveableBackStack, onRootPop: () -> Unit ?): Navigator Returns a new Navigator for navigating within CircuitContents.","title":"rememberCircuitNavigator"},{"location":"api/0.x/circuit/com.slack.circuit/remember-circuit-navigator/#see-also","text":"android NavigableCircuitContent","title":"See also"},{"location":"api/0.x/circuit/com.slack.circuit/remember-circuit-navigator/#parameters","text":"android backstack The backing SaveableBackStack to navigate. onRootPop The callback to handle root Navigator.pop calls.","title":"Parameters"},{"location":"api/0.x/circuit/com.slack.circuit/screen/","text":"// circuit / com.slack.circuit / screen screen \u00b6 [android]\\ val SaveableBackStack.Record. screen : Screen","title":"Screen"},{"location":"api/0.x/circuit/com.slack.circuit/screen/#screen","text":"[android]\\ val SaveableBackStack.Record. screen : Screen","title":"screen"},{"location":"api/0.x/circuit/com.slack.circuit/ui/","text":"// circuit / com.slack.circuit / ui ui \u00b6 [common]\\ inline fun < UiState : CircuitUiState > ui (crossinline body: @ Composable (state: UiState ) -> Unit ): Ui < UiState > Due to this bug in Studio, we can\u2019t write lambda impls of Ui directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Ui a fun interface instead. Bug: https://issuetracker.google.com/issues/240292828 See also \u00b6 common com.slack.circuit.Ui for main docs.","title":"Ui"},{"location":"api/0.x/circuit/com.slack.circuit/ui/#ui","text":"[common]\\ inline fun < UiState : CircuitUiState > ui (crossinline body: @ Composable (state: UiState ) -> Unit ): Ui < UiState > Due to this bug in Studio, we can\u2019t write lambda impls of Ui directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Ui a fun interface instead. Bug: https://issuetracker.google.com/issues/240292828","title":"ui"},{"location":"api/0.x/circuit/com.slack.circuit/ui/#see-also","text":"common com.slack.circuit.Ui for main docs.","title":"See also"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/","text":"// circuit / com.slack.circuit / CircuitConfig CircuitConfig \u00b6 [common]\\ @ Immutable class CircuitConfig CircuitConfig adapts presenter factories to their corresponding renderable ui factories using screens . Create instances using the Builder and create new CircuitContent with it to run presenter/UI pairings. Construction \u00b6 Construction of CircuitConfig instances is done using the Builder . val circuitConfig = CircuitConfig . Builder () . addUiFactory ( AddFavoritesUiFactory () . addPresenterFactory ( AddFavoritesPresenterFactory () . build () Usage \u00b6 These instances can then be used with the composable CircuitContent functions to run presenter/UI pairings for individual screens . Circuit instances are consumed within these composable functions via the CircuitCompositionLocals CompositionLocalProvider. CircuitCompositionLocals ( circuitConfig ) { CircuitContent ( AddFavoritesScreen ()) } If using navigation, use NavigableCircuitContent instead. val backstack = rememberSaveableBackStack { push ( AddFavoritesScreen ()) } val navigator = rememberCircuitNavigator ( backstack , :: onBackPressed ) CircuitCompositionLocals ( circuitConfig ) { NavigableCircuitContent ( navigator , backstack ) } See also \u00b6 common rememberCircuitNavigator CircuitContent NavigableCircuitContent Types \u00b6 Name Summary Builder [common] class Builder Functions \u00b6 Name Summary newBuilder [common] fun newBuilder (): CircuitConfig.Builder nextPresenter [common] fun nextPresenter (skipPast: Presenter.Factory ?, screen: Screen , navigator: Navigator ): Presenter <*>? nextUi [common] fun nextUi (skipPast: Ui.Factory ?, screen: Screen ): ScreenUi ? presenter [common] fun presenter (screen: Screen , navigator: Navigator ): Presenter <*>? ui [common] fun ui (screen: Screen ): ScreenUi ? Properties \u00b6 Name Summary onUnavailableContent [common] val onUnavailableContent : @ Composable (screen: Screen ) -> Unit ?","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/#circuitconfig","text":"[common]\\ @ Immutable class CircuitConfig CircuitConfig adapts presenter factories to their corresponding renderable ui factories using screens . Create instances using the Builder and create new CircuitContent with it to run presenter/UI pairings.","title":"CircuitConfig"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/#construction","text":"Construction of CircuitConfig instances is done using the Builder . val circuitConfig = CircuitConfig . Builder () . addUiFactory ( AddFavoritesUiFactory () . addPresenterFactory ( AddFavoritesPresenterFactory () . build ()","title":"Construction"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/#usage","text":"These instances can then be used with the composable CircuitContent functions to run presenter/UI pairings for individual screens . Circuit instances are consumed within these composable functions via the CircuitCompositionLocals CompositionLocalProvider. CircuitCompositionLocals ( circuitConfig ) { CircuitContent ( AddFavoritesScreen ()) } If using navigation, use NavigableCircuitContent instead. val backstack = rememberSaveableBackStack { push ( AddFavoritesScreen ()) } val navigator = rememberCircuitNavigator ( backstack , :: onBackPressed ) CircuitCompositionLocals ( circuitConfig ) { NavigableCircuitContent ( navigator , backstack ) }","title":"Usage"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/#see-also","text":"common rememberCircuitNavigator CircuitContent NavigableCircuitContent","title":"See also"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/#types","text":"Name Summary Builder [common] class Builder","title":"Types"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/#functions","text":"Name Summary newBuilder [common] fun newBuilder (): CircuitConfig.Builder nextPresenter [common] fun nextPresenter (skipPast: Presenter.Factory ?, screen: Screen , navigator: Navigator ): Presenter <*>? nextUi [common] fun nextUi (skipPast: Ui.Factory ?, screen: Screen ): ScreenUi ? presenter [common] fun presenter (screen: Screen , navigator: Navigator ): Presenter <*>? ui [common] fun ui (screen: Screen ): ScreenUi ?","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/#properties","text":"Name Summary onUnavailableContent [common] val onUnavailableContent : @ Composable (screen: Screen ) -> Unit ?","title":"Properties"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/new-builder/","text":"// circuit / com.slack.circuit / CircuitConfig / newBuilder newBuilder \u00b6 [common]\\ fun newBuilder (): CircuitConfig.Builder","title":"New builder"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/new-builder/#newbuilder","text":"[common]\\ fun newBuilder (): CircuitConfig.Builder","title":"newBuilder"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/next-presenter/","text":"// circuit / com.slack.circuit / CircuitConfig / nextPresenter nextPresenter \u00b6 [common]\\ fun nextPresenter (skipPast: Presenter.Factory ?, screen: Screen , navigator: Navigator ): Presenter <*>?","title":"Next presenter"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/next-presenter/#nextpresenter","text":"[common]\\ fun nextPresenter (skipPast: Presenter.Factory ?, screen: Screen , navigator: Navigator ): Presenter <*>?","title":"nextPresenter"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/next-ui/","text":"// circuit / com.slack.circuit / CircuitConfig / nextUi nextUi \u00b6 [common]\\ fun nextUi (skipPast: Ui.Factory ?, screen: Screen ): ScreenUi ?","title":"Next ui"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/next-ui/#nextui","text":"[common]\\ fun nextUi (skipPast: Ui.Factory ?, screen: Screen ): ScreenUi ?","title":"nextUi"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/on-unavailable-content/","text":"// circuit / com.slack.circuit / CircuitConfig / onUnavailableContent onUnavailableContent \u00b6 [common]\\ val onUnavailableContent : @ Composable (screen: Screen ) -> Unit ?","title":"On unavailable content"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/on-unavailable-content/#onunavailablecontent","text":"[common]\\ val onUnavailableContent : @ Composable (screen: Screen ) -> Unit ?","title":"onUnavailableContent"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/presenter/","text":"// circuit / com.slack.circuit / CircuitConfig / presenter presenter \u00b6 [common]\\ fun presenter (screen: Screen , navigator: Navigator ): Presenter <*>?","title":"Presenter"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/presenter/#presenter","text":"[common]\\ fun presenter (screen: Screen , navigator: Navigator ): Presenter <*>?","title":"presenter"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/ui/","text":"// circuit / com.slack.circuit / CircuitConfig / ui ui \u00b6 [common]\\ fun ui (screen: Screen ): ScreenUi ?","title":"Ui"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/ui/#ui","text":"[common]\\ fun ui (screen: Screen ): ScreenUi ?","title":"ui"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder Builder \u00b6 [common]\\ class Builder Constructors \u00b6 Builder [common] fun Builder () Functions \u00b6 Name Summary addPresenterFactories [common] fun addPresenterFactories (factories: Iterable < Presenter.Factory >): CircuitConfig.Builder addPresenterFactory [common] fun addPresenterFactory (factory: Presenter.Factory ): CircuitConfig.Builder fun addPresenterFactory (vararg factory: Presenter.Factory ): CircuitConfig.Builder addUiFactories [common] fun addUiFactories (factories: Iterable < Ui.Factory >): CircuitConfig.Builder addUiFactory [common] fun addUiFactory (factory: Ui.Factory ): CircuitConfig.Builder fun addUiFactory (vararg factory: Ui.Factory ): CircuitConfig.Builder build [common] fun build (): CircuitConfig setOnUnavailableContentCallback [common] fun setOnUnavailableContentCallback (callback: @ Composable (screen: Screen ) -> Unit ): CircuitConfig.Builder Properties \u00b6 Name Summary onUnavailableContent [common] var onUnavailableContent : @ Composable (screen: Screen ) -> Unit ? = null presenterFactories [common] val presenterFactories : MutableList < Presenter.Factory > uiFactories [common] val uiFactories : MutableList < Ui.Factory >","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/#builder","text":"[common]\\ class Builder","title":"Builder"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/#constructors","text":"Builder [common] fun Builder ()","title":"Constructors"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/#functions","text":"Name Summary addPresenterFactories [common] fun addPresenterFactories (factories: Iterable < Presenter.Factory >): CircuitConfig.Builder addPresenterFactory [common] fun addPresenterFactory (factory: Presenter.Factory ): CircuitConfig.Builder fun addPresenterFactory (vararg factory: Presenter.Factory ): CircuitConfig.Builder addUiFactories [common] fun addUiFactories (factories: Iterable < Ui.Factory >): CircuitConfig.Builder addUiFactory [common] fun addUiFactory (factory: Ui.Factory ): CircuitConfig.Builder fun addUiFactory (vararg factory: Ui.Factory ): CircuitConfig.Builder build [common] fun build (): CircuitConfig setOnUnavailableContentCallback [common] fun setOnUnavailableContentCallback (callback: @ Composable (screen: Screen ) -> Unit ): CircuitConfig.Builder","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/#properties","text":"Name Summary onUnavailableContent [common] var onUnavailableContent : @ Composable (screen: Screen ) -> Unit ? = null presenterFactories [common] val presenterFactories : MutableList < Presenter.Factory > uiFactories [common] val uiFactories : MutableList < Ui.Factory >","title":"Properties"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/-builder/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / Builder Builder \u00b6 [common]\\ fun Builder ()","title":" builder"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/-builder/#builder","text":"[common]\\ fun Builder ()","title":"Builder"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-presenter-factories/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / addPresenterFactories addPresenterFactories \u00b6 [common]\\ fun addPresenterFactories (factories: Iterable < Presenter.Factory >): CircuitConfig.Builder","title":"Add presenter factories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-presenter-factories/#addpresenterfactories","text":"[common]\\ fun addPresenterFactories (factories: Iterable < Presenter.Factory >): CircuitConfig.Builder","title":"addPresenterFactories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-presenter-factory/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / addPresenterFactory addPresenterFactory \u00b6 [common]\\ fun addPresenterFactory (factory: Presenter.Factory ): CircuitConfig.Builder fun addPresenterFactory (vararg factory: Presenter.Factory ): CircuitConfig.Builder","title":"Add presenter factory"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-presenter-factory/#addpresenterfactory","text":"[common]\\ fun addPresenterFactory (factory: Presenter.Factory ): CircuitConfig.Builder fun addPresenterFactory (vararg factory: Presenter.Factory ): CircuitConfig.Builder","title":"addPresenterFactory"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-ui-factories/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / addUiFactories addUiFactories \u00b6 [common]\\ fun addUiFactories (factories: Iterable < Ui.Factory >): CircuitConfig.Builder","title":"Add ui factories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-ui-factories/#adduifactories","text":"[common]\\ fun addUiFactories (factories: Iterable < Ui.Factory >): CircuitConfig.Builder","title":"addUiFactories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-ui-factory/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / addUiFactory addUiFactory \u00b6 [common]\\ fun addUiFactory (factory: Ui.Factory ): CircuitConfig.Builder fun addUiFactory (vararg factory: Ui.Factory ): CircuitConfig.Builder","title":"Add ui factory"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-ui-factory/#adduifactory","text":"[common]\\ fun addUiFactory (factory: Ui.Factory ): CircuitConfig.Builder fun addUiFactory (vararg factory: Ui.Factory ): CircuitConfig.Builder","title":"addUiFactory"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/build/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / build build \u00b6 [common]\\ fun build (): CircuitConfig","title":"Build"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/build/#build","text":"[common]\\ fun build (): CircuitConfig","title":"build"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/on-unavailable-content/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / onUnavailableContent onUnavailableContent \u00b6 [common]\\ var onUnavailableContent : @ Composable (screen: Screen ) -> Unit ? = null","title":"On unavailable content"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/on-unavailable-content/#onunavailablecontent","text":"[common]\\ var onUnavailableContent : @ Composable (screen: Screen ) -> Unit ? = null","title":"onUnavailableContent"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/presenter-factories/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / presenterFactories presenterFactories \u00b6 [common]\\ val presenterFactories : MutableList < Presenter.Factory >","title":"Presenter factories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/presenter-factories/#presenterfactories","text":"[common]\\ val presenterFactories : MutableList < Presenter.Factory >","title":"presenterFactories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/set-on-unavailable-content-callback/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / setOnUnavailableContentCallback setOnUnavailableContentCallback \u00b6 [common]\\ fun setOnUnavailableContentCallback (callback: @ Composable (screen: Screen ) -> Unit ): CircuitConfig.Builder","title":"Set on unavailable content callback"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/set-on-unavailable-content-callback/#setonunavailablecontentcallback","text":"[common]\\ fun setOnUnavailableContentCallback (callback: @ Composable (screen: Screen ) -> Unit ): CircuitConfig.Builder","title":"setOnUnavailableContentCallback"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/ui-factories/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / uiFactories uiFactories \u00b6 [common]\\ val uiFactories : MutableList < Ui.Factory >","title":"Ui factories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/ui-factories/#uifactories","text":"[common]\\ val uiFactories : MutableList < Ui.Factory >","title":"uiFactories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-ui-event/","text":"// circuit / com.slack.circuit / CircuitUiEvent CircuitUiEvent \u00b6 [common]\\ @ Immutable interface CircuitUiEvent Marker interface for all UiEvent types. Events in Circuit should generally reflect user interactions with the UI. They are mediated by presenters and may or may not influence the current state . Circuit event types should be truly immutable types. Inheritors \u00b6 Name NavEvent","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-ui-event/#circuituievent","text":"[common]\\ @ Immutable interface CircuitUiEvent Marker interface for all UiEvent types. Events in Circuit should generally reflect user interactions with the UI. They are mediated by presenters and may or may not influence the current state . Circuit event types should be truly immutable types.","title":"CircuitUiEvent"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-ui-event/#inheritors","text":"Name NavEvent","title":"Inheritors"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-ui-state/","text":"// circuit / com.slack.circuit / CircuitUiState CircuitUiState \u00b6 [common]\\ @ Immutable interface CircuitUiState Marker interface for all UiState types. States in Circuit should be minimal data models that UIs can render. They are produced by presenters that interpret the underlying data layer and mediate input user/nav events . UIs take states as parameters and should act as pure functions that render the input state as a UI. They should not have any side effects or directly interact with the underlying data layer. Circuit state types should be truly immutable types.","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-ui-state/#circuituistate","text":"[common]\\ @ Immutable interface CircuitUiState Marker interface for all UiState types. States in Circuit should be minimal data models that UIs can render. They are produced by presenters that interpret the underlying data layer and mediate input user/nav events . UIs take states as parameters and should act as pure functions that render the input state as a UI. They should not have any side effects or directly interact with the underlying data layer. Circuit state types should be truly immutable types.","title":"CircuitUiState"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/","text":"// circuit / com.slack.circuit / LocalCircuitOwner LocalCircuitOwner \u00b6 [common]\\ object LocalCircuitOwner Functions \u00b6 Name Summary provides [common] infix fun provides (circuitConfig: CircuitConfig ): ProvidedValue < CircuitConfig ?> Associates a LocalCircuitConfig key to a value in a call to CompositionLocalProvider . Properties \u00b6 Name Summary current [common] @get: Composable val current : CircuitConfig Returns current composition local value for the owner or errors if one has not been provided.","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/#localcircuitowner","text":"[common]\\ object LocalCircuitOwner","title":"LocalCircuitOwner"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/#functions","text":"Name Summary provides [common] infix fun provides (circuitConfig: CircuitConfig ): ProvidedValue < CircuitConfig ?> Associates a LocalCircuitConfig key to a value in a call to CompositionLocalProvider .","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/#properties","text":"Name Summary current [common] @get: Composable val current : CircuitConfig Returns current composition local value for the owner or errors if one has not been provided.","title":"Properties"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/current/","text":"// circuit / com.slack.circuit / LocalCircuitOwner / current current \u00b6 [common]\\ @get: Composable val current : CircuitConfig Returns current composition local value for the owner or errors if one has not been provided.","title":"Current"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/current/#current","text":"[common]\\ @get: Composable val current : CircuitConfig Returns current composition local value for the owner or errors if one has not been provided.","title":"current"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/provides/","text":"// circuit / com.slack.circuit / LocalCircuitOwner / provides provides \u00b6 [common]\\ infix fun provides (circuitConfig: CircuitConfig ): ProvidedValue < CircuitConfig ?> Associates a LocalCircuitConfig key to a value in a call to CompositionLocalProvider .","title":"Provides"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/provides/#provides","text":"[common]\\ infix fun provides (circuitConfig: CircuitConfig ): ProvidedValue < CircuitConfig ?> Associates a LocalCircuitConfig key to a value in a call to CompositionLocalProvider .","title":"provides"},{"location":"api/0.x/circuit/com.slack.circuit/-nav-event/","text":"// circuit / com.slack.circuit / NavEvent NavEvent \u00b6 [common]\\ interface NavEvent : CircuitUiEvent A sealed navigation interface intended to be used when making a navigation call back.","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-nav-event/#navevent","text":"[common]\\ interface NavEvent : CircuitUiEvent A sealed navigation interface intended to be used when making a navigation call back.","title":"NavEvent"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/","text":"// circuit / com.slack.circuit / Navigator Navigator \u00b6 [common]\\ @ Stable interface Navigator A basic navigation interface for navigating between screens . Types \u00b6 Name Summary NoOp [common] object NoOp : Navigator Functions \u00b6 Name Summary goTo [common] abstract fun goTo (screen: Screen ) pop [common] abstract fun pop (): Screen ? Inheritors \u00b6 Name NoOp Extensions \u00b6 Name Summary onNavEvent [common] fun Navigator . onNavEvent (event: NavEvent ) A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvent s from nested Presenter s. popUntil [common] fun Navigator . popUntil (predicate: ( Screen ) -> Boolean ) Calls Navigator.pop until the given predicate is matched or it pops the root.","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/#navigator","text":"[common]\\ @ Stable interface Navigator A basic navigation interface for navigating between screens .","title":"Navigator"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/#types","text":"Name Summary NoOp [common] object NoOp : Navigator","title":"Types"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/#functions","text":"Name Summary goTo [common] abstract fun goTo (screen: Screen ) pop [common] abstract fun pop (): Screen ?","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/#inheritors","text":"Name NoOp","title":"Inheritors"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/#extensions","text":"Name Summary onNavEvent [common] fun Navigator . onNavEvent (event: NavEvent ) A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvent s from nested Presenter s. popUntil [common] fun Navigator . popUntil (predicate: ( Screen ) -> Boolean ) Calls Navigator.pop until the given predicate is matched or it pops the root.","title":"Extensions"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/go-to/","text":"// circuit / com.slack.circuit / Navigator / goTo goTo \u00b6 [common]\\ abstract fun goTo (screen: Screen )","title":"Go to"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/go-to/#goto","text":"[common]\\ abstract fun goTo (screen: Screen )","title":"goTo"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/pop/","text":"// circuit / com.slack.circuit / Navigator / pop pop \u00b6 [common]\\ abstract fun pop (): Screen ?","title":"Pop"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/pop/#pop","text":"[common]\\ abstract fun pop (): Screen ?","title":"pop"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/-no-op/","text":"// circuit / com.slack.circuit / Navigator / NoOp NoOp \u00b6 [common]\\ object NoOp : Navigator Functions \u00b6 Name Summary goTo [common] open override fun goTo (screen: Screen ) pop [common] open override fun pop (): Screen ?","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/-no-op/#noop","text":"[common]\\ object NoOp : Navigator","title":"NoOp"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/-no-op/#functions","text":"Name Summary goTo [common] open override fun goTo (screen: Screen ) pop [common] open override fun pop (): Screen ?","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/-no-op/go-to/","text":"// circuit / com.slack.circuit / Navigator / NoOp / goTo goTo \u00b6 [common]\\ open override fun goTo (screen: Screen )","title":"Go to"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/-no-op/go-to/#goto","text":"[common]\\ open override fun goTo (screen: Screen )","title":"goTo"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/-no-op/pop/","text":"// circuit / com.slack.circuit / Navigator / NoOp / pop pop \u00b6 [common]\\ open override fun pop (): Screen ?","title":"Pop"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/-no-op/pop/#pop","text":"[common]\\ open override fun pop (): Screen ?","title":"pop"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/","text":"// circuit / com.slack.circuit / Presenter Presenter \u00b6 [common]\\ interface Presenter < UiState : CircuitUiState > Presents a given UiState . Events (if any) should be a part of the UiState itself as an eventSink: (Event) -> Unit property. If a given Presenter only ever emits the same state, you can define a single value-less object type for the state. See also \u00b6 common com.slack.circuit.Presenter for more thorough documentation. Types \u00b6 Name Summary Factory [common] fun interface Factory A factory that produces presenters for a given Screen . CircuitConfig instances use the created presenter and connects it to a given Ui for the same Screen . Functions \u00b6 Name Summary present [common] @ Composable abstract fun present (): UiState The primary Composable entry point to present a UiState . In production, a Navigator is used to automatically connect this with a corresponding Ui to render the state returned by this function.","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/#presenter","text":"[common]\\ interface Presenter < UiState : CircuitUiState > Presents a given UiState . Events (if any) should be a part of the UiState itself as an eventSink: (Event) -> Unit property. If a given Presenter only ever emits the same state, you can define a single value-less object type for the state.","title":"Presenter"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/#see-also","text":"common com.slack.circuit.Presenter for more thorough documentation.","title":"See also"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/#types","text":"Name Summary Factory [common] fun interface Factory A factory that produces presenters for a given Screen . CircuitConfig instances use the created presenter and connects it to a given Ui for the same Screen .","title":"Types"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/#functions","text":"Name Summary present [common] @ Composable abstract fun present (): UiState The primary Composable entry point to present a UiState . In production, a Navigator is used to automatically connect this with a corresponding Ui to render the state returned by this function.","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/present/","text":"// circuit / com.slack.circuit / Presenter / present present \u00b6 [common]\\ @ Composable abstract fun present (): UiState The primary Composable entry point to present a UiState . In production, a Navigator is used to automatically connect this with a corresponding Ui to render the state returned by this function. When handling events, embed a eventSink: (Event) -> Unit property in the state as needed. data class State ( val favorites : List < Favorite > , eventSink : ( Event ) -> Unit ) : CircuitUiState class FavoritesPresenter (...) : Presenter < State , Event > { @Composable override fun present (): State { // ... return State (...) { event -> // Handle UI events here } } } Dependency Injection \u00b6 Presenters should use dependency injection, usually assisted injection to accept Navigator or Screen instances as inputs. Their corresponding assisted factories should then be used by hand-written presenter factories . class FavoritesPresenter @AssistedInject constructor ( @Assisted private val screen : FavoritesScreen , @Assisted private val navigator : Navigator , private val favoritesRepository : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { // ... } @AssistedFactory fun interface Factory { fun create ( screen : FavoritesScreen , navigator : Navigator ): FavoritesPresenter } } Testing \u00b6 When testing, simply drive UI events with a MutableSharedFlow use Molecule+Turbine to drive this function. @Test fun `emit initial state and refresh` () = runTest { val favorites = listOf ( \"Moose\" , \"Reeses\" , \"Lola\" ) val repository = FakeFavoritesRepository ( favorites ) val presenter = FavoritesPresenter ( repository ) moleculeFlow ( Immediate ) { presenter . present () } . test { assertThat ( awaitItem ()). isEqualTo ( State . Loading ) val successState = awaitItem () assertThat ( successState ). isEqualTo ( State . Success ( favorites )) successState . eventSink ( Event . Refresh ) assertThat ( awaitItem ()). isEqualTo ( State . Success ( favorites )) } } Note that Circuit\u2019s test artifact has a Presenter.test() helper extension function for the above case.","title":"Present"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/present/#present","text":"[common]\\ @ Composable abstract fun present (): UiState The primary Composable entry point to present a UiState . In production, a Navigator is used to automatically connect this with a corresponding Ui to render the state returned by this function. When handling events, embed a eventSink: (Event) -> Unit property in the state as needed. data class State ( val favorites : List < Favorite > , eventSink : ( Event ) -> Unit ) : CircuitUiState class FavoritesPresenter (...) : Presenter < State , Event > { @Composable override fun present (): State { // ... return State (...) { event -> // Handle UI events here } } }","title":"present"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/present/#dependency-injection","text":"Presenters should use dependency injection, usually assisted injection to accept Navigator or Screen instances as inputs. Their corresponding assisted factories should then be used by hand-written presenter factories . class FavoritesPresenter @AssistedInject constructor ( @Assisted private val screen : FavoritesScreen , @Assisted private val navigator : Navigator , private val favoritesRepository : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { // ... } @AssistedFactory fun interface Factory { fun create ( screen : FavoritesScreen , navigator : Navigator ): FavoritesPresenter } }","title":"Dependency Injection"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/present/#testing","text":"When testing, simply drive UI events with a MutableSharedFlow use Molecule+Turbine to drive this function. @Test fun `emit initial state and refresh` () = runTest { val favorites = listOf ( \"Moose\" , \"Reeses\" , \"Lola\" ) val repository = FakeFavoritesRepository ( favorites ) val presenter = FavoritesPresenter ( repository ) moleculeFlow ( Immediate ) { presenter . present () } . test { assertThat ( awaitItem ()). isEqualTo ( State . Loading ) val successState = awaitItem () assertThat ( successState ). isEqualTo ( State . Success ( favorites )) successState . eventSink ( Event . Refresh ) assertThat ( awaitItem ()). isEqualTo ( State . Success ( favorites )) } } Note that Circuit\u2019s test artifact has a Presenter.test() helper extension function for the above case.","title":"Testing"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/-factory/","text":"// circuit / com.slack.circuit / Presenter / Factory Factory \u00b6 [common]\\ fun interface Factory A factory that produces presenters for a given Screen . CircuitConfig instances use the created presenter and connects it to a given Ui for the same Screen . Factories should be simple aggregate multiple presenters for a canonical \"whole screen\". That is to say, they should be hand-written and aggregate all the presenters responsible for the UI visible within the surface this presents on. Example \u00b6 Consider this example of a Profile UI. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4\u2500\u2500\u2510 \u2502 \u2502 X \u2502 \u2502 \u2502 \u2502 \u2502 ProfileHeaderPresenter \u2502 \u2502 Fred Rogers \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2510 \u2502 ProfilePresenterFactory \u2502 \u2502 Message \u2502 \u2502 Call \u2502\u25c4\u2500\u253c\u2500\u2500\u2500 ProfileActionsPresenter \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 - - - - - - - - \u25c4\u2500\u253c\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 - - - - - - - - \u2502 \u2502 \u2502 \u2502 - - - - - - - - \u2502 ProfileDetailsPresenter \u2502 \u2502 - - - - - - - - \u25c4\u2500\u253c\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 This would be represented by the following factory implementation: class ProfilePresenter . Factory @Inject constructor ( val headerPresenter : ProfilerHeaderPresenter . Factory , val actionsPresenter : ProfilerActionsPresenter . Factory , val detailsPresenter : ProfilerDetailsPresenter . Factory , val callScreenRouter : CallScreenRouter . Factory ) : Presenter . Factory { override fun create ( screen : Screen , navigator : Navigator , circuitConfig : CircuitConfig ): Presenter <* , *>? { return when ( screen ) { is ProfileHeader -> headerPresenter . create ( screen ) is ProfileActions -> actionsPresenter . create ( screen , callScreenRouter . create ( navigator )) is ProfileDetails -> detailsPresenter . create ( screen ) else -> null } } } Functions \u00b6 Name Summary create [common] abstract fun create (screen: Screen , navigator: Navigator , circuitConfig: CircuitConfig ): Presenter <*>? Creates a Presenter for the given screen if it can handle it, or returns null if it cannot handle the given screen .","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/-factory/#factory","text":"[common]\\ fun interface Factory A factory that produces presenters for a given Screen . CircuitConfig instances use the created presenter and connects it to a given Ui for the same Screen . Factories should be simple aggregate multiple presenters for a canonical \"whole screen\". That is to say, they should be hand-written and aggregate all the presenters responsible for the UI visible within the surface this presents on.","title":"Factory"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/-factory/#example","text":"Consider this example of a Profile UI. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4\u2500\u2500\u2510 \u2502 \u2502 X \u2502 \u2502 \u2502 \u2502 \u2502 ProfileHeaderPresenter \u2502 \u2502 Fred Rogers \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2510 \u2502 ProfilePresenterFactory \u2502 \u2502 Message \u2502 \u2502 Call \u2502\u25c4\u2500\u253c\u2500\u2500\u2500 ProfileActionsPresenter \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 - - - - - - - - \u25c4\u2500\u253c\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 - - - - - - - - \u2502 \u2502 \u2502 \u2502 - - - - - - - - \u2502 ProfileDetailsPresenter \u2502 \u2502 - - - - - - - - \u25c4\u2500\u253c\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 This would be represented by the following factory implementation: class ProfilePresenter . Factory @Inject constructor ( val headerPresenter : ProfilerHeaderPresenter . Factory , val actionsPresenter : ProfilerActionsPresenter . Factory , val detailsPresenter : ProfilerDetailsPresenter . Factory , val callScreenRouter : CallScreenRouter . Factory ) : Presenter . Factory { override fun create ( screen : Screen , navigator : Navigator , circuitConfig : CircuitConfig ): Presenter <* , *>? { return when ( screen ) { is ProfileHeader -> headerPresenter . create ( screen ) is ProfileActions -> actionsPresenter . create ( screen , callScreenRouter . create ( navigator )) is ProfileDetails -> detailsPresenter . create ( screen ) else -> null } } }","title":"Example"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/-factory/#functions","text":"Name Summary create [common] abstract fun create (screen: Screen , navigator: Navigator , circuitConfig: CircuitConfig ): Presenter <*>? Creates a Presenter for the given screen if it can handle it, or returns null if it cannot handle the given screen .","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/-factory/create/","text":"// circuit / com.slack.circuit / Presenter / Factory / create create \u00b6 [common]\\ abstract fun create (screen: Screen , navigator: Navigator , circuitConfig: CircuitConfig ): Presenter <*>? Creates a Presenter for the given screen if it can handle it, or returns null if it cannot handle the given screen .","title":"Create"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/-factory/create/#create","text":"[common]\\ abstract fun create (screen: Screen , navigator: Navigator , circuitConfig: CircuitConfig ): Presenter <*>? Creates a Presenter for the given screen if it can handle it, or returns null if it cannot handle the given screen .","title":"create"},{"location":"api/0.x/circuit/com.slack.circuit/-screen/","text":"// circuit / com.slack.circuit / Screen Screen \u00b6 [common]\\ expect interface Screen Represents an individual screen, used as a key for Presenter.Factory and Ui.Factory . Screens can be simple sentinel object types or data classes with information to share. Screens with information should contain the minimum amount of data needed for the target presenter to begin presenting state. data class AddFavorites ( val externalId : UUID , ) : Screen Screens are then passed into Navigators to navigate to them. fun showAddFavorites () { navigator . goTo ( AddFavorites ( externalId = uuidGenerator . generate () ) ) } [android]\\ actual interface Screen : Parcelable [jvm]\\ actual interface Screen Functions \u00b6 Name Summary describeContents [android] abstract fun describeContents (): Int writeToParcel [android] abstract fun writeToParcel (p0: Parcel , p1: Int )","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-screen/#screen","text":"[common]\\ expect interface Screen Represents an individual screen, used as a key for Presenter.Factory and Ui.Factory . Screens can be simple sentinel object types or data classes with information to share. Screens with information should contain the minimum amount of data needed for the target presenter to begin presenting state. data class AddFavorites ( val externalId : UUID , ) : Screen Screens are then passed into Navigators to navigate to them. fun showAddFavorites () { navigator . goTo ( AddFavorites ( externalId = uuidGenerator . generate () ) ) } [android]\\ actual interface Screen : Parcelable [jvm]\\ actual interface Screen","title":"Screen"},{"location":"api/0.x/circuit/com.slack.circuit/-screen/#functions","text":"Name Summary describeContents [android] abstract fun describeContents (): Int writeToParcel [android] abstract fun writeToParcel (p0: Parcel , p1: Int )","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/","text":"// circuit / com.slack.circuit / ScreenUi ScreenUi \u00b6 [common]\\ data class ScreenUi (val ui: Ui <*>) Constructors \u00b6 ScreenUi [common] fun ScreenUi (ui: Ui <*>) Properties \u00b6 Name Summary ui [common] val ui : Ui <*>","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/#screenui","text":"[common]\\ data class ScreenUi (val ui: Ui <*>)","title":"ScreenUi"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/#constructors","text":"ScreenUi [common] fun ScreenUi (ui: Ui <*>)","title":"Constructors"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/#properties","text":"Name Summary ui [common] val ui : Ui <*>","title":"Properties"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/-screen-ui/","text":"// circuit / com.slack.circuit / ScreenUi / ScreenUi ScreenUi \u00b6 [common]\\ fun ScreenUi (ui: Ui <*>)","title":" screen ui"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/-screen-ui/#screenui","text":"[common]\\ fun ScreenUi (ui: Ui <*>)","title":"ScreenUi"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/ui/","text":"// circuit / com.slack.circuit / ScreenUi / ui ui \u00b6 [common]\\ val ui : Ui <*>","title":"Ui"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/ui/#ui","text":"[common]\\ val ui : Ui <*>","title":"ui"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/","text":"// circuit / com.slack.circuit / Ui Ui \u00b6 [common]\\ interface Ui < UiState : CircuitUiState > Represents a composable UI for the given UiState . Conventionally, this should just be the return type of a ui function and a thin shim over a \"real\" implementation. This has two main benefits: Discouraging properties and general non-composable state that writing a class may invite. Ensuring separation of Ui instance from Screen specific ui composables allows for and encourages easy UI previews via Compose\u2019s Preview annotations. Usage: internal fun tacoUi (): Ui < State > = ui { state -> Tacos ( state ) } @Composable private fun Tacos ( state : State ) {...} @Preview @Composable private fun PreviewTacos () = Tacos (...) This could be a class, but isn\u2019t necessary unless you\u2019re using dependency injection. Most UIs don\u2019t use dependency injection at all however, unless maybe getting assisted injections of things like image loaders. If a given Presenter only ever emits the same state, you can define a single value-less object type for the state. Note that due to a bug in studio, we can\u2019t make this a fun interface yet . Instead, use ui . See also \u00b6 common ui Types \u00b6 Name Summary Factory [common] fun interface Factory A factory that creates ScreenUis , which in turn contain the desired Ui for a given Screen . Functions \u00b6 Name Summary Content [common] @ Composable abstract fun Content (state: UiState )","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/#ui","text":"[common]\\ interface Ui < UiState : CircuitUiState > Represents a composable UI for the given UiState . Conventionally, this should just be the return type of a ui function and a thin shim over a \"real\" implementation. This has two main benefits: Discouraging properties and general non-composable state that writing a class may invite. Ensuring separation of Ui instance from Screen specific ui composables allows for and encourages easy UI previews via Compose\u2019s Preview annotations. Usage: internal fun tacoUi (): Ui < State > = ui { state -> Tacos ( state ) } @Composable private fun Tacos ( state : State ) {...} @Preview @Composable private fun PreviewTacos () = Tacos (...) This could be a class, but isn\u2019t necessary unless you\u2019re using dependency injection. Most UIs don\u2019t use dependency injection at all however, unless maybe getting assisted injections of things like image loaders. If a given Presenter only ever emits the same state, you can define a single value-less object type for the state. Note that due to a bug in studio, we can\u2019t make this a fun interface yet . Instead, use ui .","title":"Ui"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/#see-also","text":"common ui","title":"See also"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/#types","text":"Name Summary Factory [common] fun interface Factory A factory that creates ScreenUis , which in turn contain the desired Ui for a given Screen .","title":"Types"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/#functions","text":"Name Summary Content [common] @ Composable abstract fun Content (state: UiState )","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/-content/","text":"// circuit / com.slack.circuit / Ui / Content Content \u00b6 [common]\\ @ Composable abstract fun Content (state: UiState )","title":" content"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/-content/#content","text":"[common]\\ @ Composable abstract fun Content (state: UiState )","title":"Content"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/-factory/","text":"// circuit / com.slack.circuit / Ui / Factory Factory \u00b6 [common]\\ fun interface Factory A factory that creates ScreenUis , which in turn contain the desired Ui for a given Screen . Note that individual UIs should just be top-level ui function calls that factories simply call into. This allows easily standing up composable preview functions. class FavoritesUiFactory @Inject constructor () : Ui . Factory { override fun create ( screen : Screen , circuitConfig : CircuitConfig ): ScreenUi? { val ui = when ( screen ) { is AddFavorites -> { addFavoritesUi () } else -> return null } return ScreenUi ( ui = ui as Ui <* , *> , ) } } private fun addFavoritesUi () = ui < AddFavorites . State > { state -> Favorites ( state ) } @Composable private fun Favorites ( state : State ) {...} Functions \u00b6 Name Summary create [common] abstract fun create (screen: Screen , circuitConfig: CircuitConfig ): ScreenUi ?","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/-factory/#factory","text":"[common]\\ fun interface Factory A factory that creates ScreenUis , which in turn contain the desired Ui for a given Screen . Note that individual UIs should just be top-level ui function calls that factories simply call into. This allows easily standing up composable preview functions. class FavoritesUiFactory @Inject constructor () : Ui . Factory { override fun create ( screen : Screen , circuitConfig : CircuitConfig ): ScreenUi? { val ui = when ( screen ) { is AddFavorites -> { addFavoritesUi () } else -> return null } return ScreenUi ( ui = ui as Ui <* , *> , ) } } private fun addFavoritesUi () = ui < AddFavorites . State > { state -> Favorites ( state ) } @Composable private fun Favorites ( state : State ) {...}","title":"Factory"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/-factory/#functions","text":"Name Summary create [common] abstract fun create (screen: Screen , circuitConfig: CircuitConfig ): ScreenUi ?","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/-factory/create/","text":"// circuit / com.slack.circuit / Ui / Factory / create create \u00b6 [common]\\ abstract fun create (screen: Screen , circuitConfig: CircuitConfig ): ScreenUi ?","title":"Create"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/-factory/create/#create","text":"[common]\\ abstract fun create (screen: Screen , circuitConfig: CircuitConfig ): ScreenUi ?","title":"create"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/","text":"// circuit-retained / com.slack.circuit.retained Package com.slack.circuit.retained \u00b6 Types \u00b6 Name Summary Continuity [android] class Continuity : ViewModel , RetainedStateRegistry LocalRetainedStateRegistryOwner [common] object LocalRetainedStateRegistryOwner CompositionLocal with a current RetainedStateRegistry instance. RetainedStateRegistry [common] interface RetainedStateRegistry Allows components to save and restore their state using the onRetainNonConfigurationInstance mechanism. Functions \u00b6 Name Summary continuityRetainedStateRegistry [android] @ Composable fun continuityRetainedStateRegistry (): RetainedStateRegistry produceRetainedState [common] @ Composable fun < T > produceRetainedState (initialValue: T , producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time without a defined data source. [common] @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 . [common] @ Composable fun < T > produceRetainedState (initialValue: T , vararg keys: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from keys . [common] @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 and key2 . [common] @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, key3: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 , key2 and key3 . rememberRetained [common] @ Composable fun < T : Any > rememberRetained (vararg inputs: Any ?, key: String ? = null, init: () -> T ): T Remember the value produced by init . RetainedStateRegistry [common] fun RetainedStateRegistry (values: Map < String , List < Any ?>>?): RetainedStateRegistry Creates RetainedStateRegistry .","title":"circuit-retained"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/#package-comslackcircuitretained","text":"","title":"Package com.slack.circuit.retained"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/#types","text":"Name Summary Continuity [android] class Continuity : ViewModel , RetainedStateRegistry LocalRetainedStateRegistryOwner [common] object LocalRetainedStateRegistryOwner CompositionLocal with a current RetainedStateRegistry instance. RetainedStateRegistry [common] interface RetainedStateRegistry Allows components to save and restore their state using the onRetainNonConfigurationInstance mechanism.","title":"Types"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/#functions","text":"Name Summary continuityRetainedStateRegistry [android] @ Composable fun continuityRetainedStateRegistry (): RetainedStateRegistry produceRetainedState [common] @ Composable fun < T > produceRetainedState (initialValue: T , producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time without a defined data source. [common] @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 . [common] @ Composable fun < T > produceRetainedState (initialValue: T , vararg keys: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from keys . [common] @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 and key2 . [common] @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, key3: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 , key2 and key3 . rememberRetained [common] @ Composable fun < T : Any > rememberRetained (vararg inputs: Any ?, key: String ? = null, init: () -> T ): T Remember the value produced by init . RetainedStateRegistry [common] fun RetainedStateRegistry (values: Map < String , List < Any ?>>?): RetainedStateRegistry Creates RetainedStateRegistry .","title":"Functions"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/","text":"// circuit-retained / com.slack.circuit.retained / RetainedStateRegistry RetainedStateRegistry \u00b6 [common]\\ fun RetainedStateRegistry (values: Map < String , List < Any ?>>?): RetainedStateRegistry Creates RetainedStateRegistry . Parameters \u00b6 common values The map of the restored values","title":" retained state registry"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#retainedstateregistry","text":"[common]\\ fun RetainedStateRegistry (values: Map < String , List < Any ?>>?): RetainedStateRegistry Creates RetainedStateRegistry .","title":"RetainedStateRegistry"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#parameters","text":"common values The map of the restored values","title":"Parameters"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/continuity-retained-state-registry/","text":"// circuit-retained / com.slack.circuit.retained / continuityRetainedStateRegistry continuityRetainedStateRegistry \u00b6 [android]\\ @ Composable fun continuityRetainedStateRegistry (): RetainedStateRegistry","title":"Continuity retained state registry"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/continuity-retained-state-registry/#continuityretainedstateregistry","text":"[android]\\ @ Composable fun continuityRetainedStateRegistry (): RetainedStateRegistry","title":"continuityRetainedStateRegistry"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/produce-retained-state/","text":"// circuit-retained / com.slack.circuit.retained / produceRetainedState produceRetainedState \u00b6 [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time without a defined data source. producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If key1 changes, a running producer will be cancelled and re-launched for the new source. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 and key2 . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If key1 or key2 change, a running producer will be cancelled and re-launched for the new source. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, key3: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 , key2 and key3 . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If key1 , key2 or key3 change, a running producer will be cancelled and re-launched for the new source. [producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , vararg keys: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from keys . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If keys change, a running producer will be cancelled and re-launched for the new source. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state }","title":"Produce retained state"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/produce-retained-state/#produceretainedstate","text":"[common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time without a defined data source. producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If key1 changes, a running producer will be cancelled and re-launched for the new source. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 and key2 . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If key1 or key2 change, a running producer will be cancelled and re-launched for the new source. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, key3: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 , key2 and key3 . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If key1 , key2 or key3 change, a running producer will be cancelled and re-launched for the new source. [producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , vararg keys: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from keys . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If keys change, a running producer will be cancelled and re-launched for the new source. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state }","title":"produceRetainedState"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/remember-retained/","text":"// circuit-retained / com.slack.circuit.retained / rememberRetained rememberRetained \u00b6 [common]\\ @ Composable fun < T : Any > rememberRetained (vararg inputs: Any ?, key: String ? = null, init: () -> T ): T Remember the value produced by init . It behaves similarly to remember , but the stored value will survive configuration changes, such as a screen rotation. You can use it with a value stored inside androidx.compose.runtime.mutableStateOf . This differs from rememberSaveable by not being tied to Android bundles or parcelable. You should take care to ensure that the state computed by init does not capture anything that is not save to persist across reconfiguration, such as Navigators. The same caveats of rememberSaveable also still apply (i.e. do not retain Android Contexts, Views, etc). However, it does not participate in saved instance state either, so care should be taken to choose the right retention mechanism for your use case. Consider the below two examples. The first case will retain state across configuration changes but will not survive process death. @Composable override fun present (): CounterState { var state by rememberRetained { mutableStateOf ( CounterState ( 0 )) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> state = state . copy ( count = state . count + 1 ) is CounterEvent . Decrement -> state = state . copy ( count = state . count - 1 ) } } } This second case will retain count across configuration changes and survive process death. However, it only works with primitives or Parcelable state types. @Composable override fun present (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> state = count ++ is CounterEvent . Decrement -> state = count -- } } } Parameters \u00b6 common inputs A set of inputs such that, when any of them have changed, will cause the state to reset and init to be rerun key An optional key to be used as a key for the saved value. If not provided we use the automatically generated by the Compose runtime which is unique for the every exact code location in the composition tree init A factory function to create the initial value of this state","title":"Remember retained"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/remember-retained/#rememberretained","text":"[common]\\ @ Composable fun < T : Any > rememberRetained (vararg inputs: Any ?, key: String ? = null, init: () -> T ): T Remember the value produced by init . It behaves similarly to remember , but the stored value will survive configuration changes, such as a screen rotation. You can use it with a value stored inside androidx.compose.runtime.mutableStateOf . This differs from rememberSaveable by not being tied to Android bundles or parcelable. You should take care to ensure that the state computed by init does not capture anything that is not save to persist across reconfiguration, such as Navigators. The same caveats of rememberSaveable also still apply (i.e. do not retain Android Contexts, Views, etc). However, it does not participate in saved instance state either, so care should be taken to choose the right retention mechanism for your use case. Consider the below two examples. The first case will retain state across configuration changes but will not survive process death. @Composable override fun present (): CounterState { var state by rememberRetained { mutableStateOf ( CounterState ( 0 )) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> state = state . copy ( count = state . count + 1 ) is CounterEvent . Decrement -> state = state . copy ( count = state . count - 1 ) } } } This second case will retain count across configuration changes and survive process death. However, it only works with primitives or Parcelable state types. @Composable override fun present (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> state = count ++ is CounterEvent . Decrement -> state = count -- } } }","title":"rememberRetained"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/remember-retained/#parameters","text":"common inputs A set of inputs such that, when any of them have changed, will cause the state to reset and init to be rerun key An optional key to be used as a key for the saved value. If not provided we use the automatically generated by the Compose runtime which is unique for the every exact code location in the composition tree init A factory function to create the initial value of this state","title":"Parameters"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/","text":"// circuit-retained / com.slack.circuit.retained / Continuity Continuity \u00b6 [android]\\ class Continuity : ViewModel , RetainedStateRegistry Constructors \u00b6 Continuity [android] fun Continuity () Functions \u00b6 Name Summary addCloseable [android] open fun addCloseable (@ NonNull p0: Closeable ) consumeValue [android] open override fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice. registerValue [android] open override fun registerValue (key: String , value: Any ?): RetainedStateRegistry.Entry Registers the value provider.","title":"Index"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/#continuity","text":"[android]\\ class Continuity : ViewModel , RetainedStateRegistry","title":"Continuity"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/#constructors","text":"Continuity [android] fun Continuity ()","title":"Constructors"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/#functions","text":"Name Summary addCloseable [android] open fun addCloseable (@ NonNull p0: Closeable ) consumeValue [android] open override fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice. registerValue [android] open override fun registerValue (key: String , value: Any ?): RetainedStateRegistry.Entry Registers the value provider.","title":"Functions"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/-continuity/","text":"// circuit-retained / com.slack.circuit.retained / Continuity / Continuity Continuity \u00b6 [android]\\ fun Continuity ()","title":" continuity"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/-continuity/#continuity","text":"[android]\\ fun Continuity ()","title":"Continuity"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/consume-value/","text":"// circuit-retained / com.slack.circuit.retained / Continuity / consumeValue consumeValue \u00b6 [android]\\ open override fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice. Parameters \u00b6 android key Key used to save the value","title":"Consume value"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/consume-value/#consumevalue","text":"[android]\\ open override fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice.","title":"consumeValue"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/consume-value/#parameters","text":"android key Key used to save the value","title":"Parameters"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/register-value/","text":"// circuit-retained / com.slack.circuit.retained / Continuity / registerValue registerValue \u00b6 [android]\\ open override fun registerValue (key: String , value: Any ?): RetainedStateRegistry.Entry Registers the value provider. There are could be multiple providers registered for the same key . In this case the order in which they were registered matters. Say we registered two values for the key. One provides \"1\", second provides \"2\". this case will have listOf(\"1\", \"2) as a value for the key in the underlying map. And later, when the registry will be recreated with the previously saved values, the first execution of consumeValue would consume \"1\" and the second one \"2\". Return \u00b6 the registry entry which you can use to unregister the provider Parameters \u00b6 android key Key to use for storing the value value The current value","title":"Register value"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/register-value/#registervalue","text":"[android]\\ open override fun registerValue (key: String , value: Any ?): RetainedStateRegistry.Entry Registers the value provider. There are could be multiple providers registered for the same key . In this case the order in which they were registered matters. Say we registered two values for the key. One provides \"1\", second provides \"2\". this case will have listOf(\"1\", \"2) as a value for the key in the underlying map. And later, when the registry will be recreated with the previously saved values, the first execution of consumeValue would consume \"1\" and the second one \"2\".","title":"registerValue"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/register-value/#return","text":"the registry entry which you can use to unregister the provider","title":"Return"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/register-value/#parameters","text":"android key Key to use for storing the value value The current value","title":"Parameters"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/","text":"// circuit-retained / com.slack.circuit.retained / LocalRetainedStateRegistryOwner LocalRetainedStateRegistryOwner \u00b6 [common]\\ object LocalRetainedStateRegistryOwner CompositionLocal with a current RetainedStateRegistry instance. Functions \u00b6 Name Summary provides [common] @ Composable infix fun provides (registry: RetainedStateRegistry ): ProvidedValue < RetainedStateRegistry > Associates a LocalRetainedStateRegistry key to a value in a call to CompositionLocalProvider . Properties \u00b6 Name Summary current [common] @get: Composable val current : RetainedStateRegistry Returns current composition local value for the owner or errors if one has not been provided.","title":"Index"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/#localretainedstateregistryowner","text":"[common]\\ object LocalRetainedStateRegistryOwner CompositionLocal with a current RetainedStateRegistry instance.","title":"LocalRetainedStateRegistryOwner"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/#functions","text":"Name Summary provides [common] @ Composable infix fun provides (registry: RetainedStateRegistry ): ProvidedValue < RetainedStateRegistry > Associates a LocalRetainedStateRegistry key to a value in a call to CompositionLocalProvider .","title":"Functions"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/#properties","text":"Name Summary current [common] @get: Composable val current : RetainedStateRegistry Returns current composition local value for the owner or errors if one has not been provided.","title":"Properties"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/current/","text":"// circuit-retained / com.slack.circuit.retained / LocalRetainedStateRegistryOwner / current current \u00b6 [common]\\ @get: Composable val current : RetainedStateRegistry Returns current composition local value for the owner or errors if one has not been provided.","title":"Current"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/current/#current","text":"[common]\\ @get: Composable val current : RetainedStateRegistry Returns current composition local value for the owner or errors if one has not been provided.","title":"current"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/provides/","text":"// circuit-retained / com.slack.circuit.retained / LocalRetainedStateRegistryOwner / provides provides \u00b6 [common]\\ @ Composable infix fun provides (registry: RetainedStateRegistry ): ProvidedValue < RetainedStateRegistry > Associates a LocalRetainedStateRegistry key to a value in a call to CompositionLocalProvider .","title":"Provides"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/provides/#provides","text":"[common]\\ @ Composable infix fun provides (registry: RetainedStateRegistry ): ProvidedValue < RetainedStateRegistry > Associates a LocalRetainedStateRegistry key to a value in a call to CompositionLocalProvider .","title":"provides"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/","text":"// circuit-retained / com.slack.circuit.retained / RetainedStateRegistry RetainedStateRegistry \u00b6 [common]\\ interface RetainedStateRegistry Allows components to save and restore their state using the onRetainNonConfigurationInstance mechanism. Types \u00b6 Name Summary Entry [common] interface Entry The registry entry which you get when you use registerValue . Functions \u00b6 Name Summary consumeValue [common] abstract fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice. registerValue [common] abstract fun registerValue (key: String , value: Any ?): RetainedStateRegistry.Entry Registers the value provider. Inheritors \u00b6 Name Continuity","title":"Index"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#retainedstateregistry","text":"[common]\\ interface RetainedStateRegistry Allows components to save and restore their state using the onRetainNonConfigurationInstance mechanism.","title":"RetainedStateRegistry"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#types","text":"Name Summary Entry [common] interface Entry The registry entry which you get when you use registerValue .","title":"Types"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#functions","text":"Name Summary consumeValue [common] abstract fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice. registerValue [common] abstract fun registerValue (key: String , value: Any ?): RetainedStateRegistry.Entry Registers the value provider.","title":"Functions"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#inheritors","text":"Name Continuity","title":"Inheritors"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/consume-value/","text":"// circuit-retained / com.slack.circuit.retained / RetainedStateRegistry / consumeValue consumeValue \u00b6 [common]\\ abstract fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice. Parameters \u00b6 common key Key used to save the value","title":"Consume value"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/consume-value/#consumevalue","text":"[common]\\ abstract fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice.","title":"consumeValue"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/consume-value/#parameters","text":"common key Key used to save the value","title":"Parameters"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/register-value/","text":"// circuit-retained / com.slack.circuit.retained / RetainedStateRegistry / registerValue registerValue \u00b6 [common]\\ abstract fun registerValue (key: String , value: Any ?): RetainedStateRegistry.Entry Registers the value provider. There are could be multiple providers registered for the same key . In this case the order in which they were registered matters. Say we registered two values for the key. One provides \"1\", second provides \"2\". this case will have listOf(\"1\", \"2) as a value for the key in the underlying map. And later, when the registry will be recreated with the previously saved values, the first execution of consumeValue would consume \"1\" and the second one \"2\". Return \u00b6 the registry entry which you can use to unregister the provider Parameters \u00b6 common key Key to use for storing the value value The current value","title":"Register value"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/register-value/#registervalue","text":"[common]\\ abstract fun registerValue (key: String , value: Any ?): RetainedStateRegistry.Entry Registers the value provider. There are could be multiple providers registered for the same key . In this case the order in which they were registered matters. Say we registered two values for the key. One provides \"1\", second provides \"2\". this case will have listOf(\"1\", \"2) as a value for the key in the underlying map. And later, when the registry will be recreated with the previously saved values, the first execution of consumeValue would consume \"1\" and the second one \"2\".","title":"registerValue"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/register-value/#return","text":"the registry entry which you can use to unregister the provider","title":"Return"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/register-value/#parameters","text":"common key Key to use for storing the value value The current value","title":"Parameters"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/-entry/","text":"// circuit-retained / com.slack.circuit.retained / RetainedStateRegistry / Entry Entry \u00b6 [common]\\ interface Entry The registry entry which you get when you use registerValue . Functions \u00b6 Name Summary unregister [common] abstract fun unregister () Unregister previously registered entry.","title":"Index"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/-entry/#entry","text":"[common]\\ interface Entry The registry entry which you get when you use registerValue .","title":"Entry"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/-entry/#functions","text":"Name Summary unregister [common] abstract fun unregister () Unregister previously registered entry.","title":"Functions"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/-entry/unregister/","text":"// circuit-retained / com.slack.circuit.retained / RetainedStateRegistry / Entry / unregister unregister \u00b6 [common]\\ abstract fun unregister () Unregister previously registered entry.","title":"Unregister"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/-entry/unregister/#unregister","text":"[common]\\ abstract fun unregister () Unregister previously registered entry.","title":"unregister"}]}